#!@INTLTOOL_PERL@ -w

#
#  The Intltool Message Updater
#
#  Copyright (C) 2000-2003 Free Software Foundation.
#
#  Intltool is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License 
#  version 2 published by the Free Software Foundation.
#
#  Intltool is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#  General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
#  As a special exception to the GNU General Public License, if you
#  distribute this file as part of a program that contains a
#  configuration script generated by Autoconf, you may include it under
#  the same distribution terms that you use for the rest of that program.
#
#  Authors: Kenneth Christiansen <kenneth@gnu.org>
#           Maciej Stachowiak
#           Darin Adler <darin@bentspoon.com>

## Release information
my $PROGRAM = "intltool-update";
my $VERSION = "0.27.1";
my $PACKAGE = "intltool";

## Loaded modules
use strict;
use Getopt::Long;
use Cwd;
use File::Copy;
use File::Find;

## Scalars used by the option stuff
my $HELP_ARG 	   = 0;
my $VERSION_ARG    = 0;
my $DIST_ARG	   = 0;
my $POT_ARG	   = 0;
my $HEADERS_ARG    = 0;
my $MAINTAIN_ARG   = 0;
my $REPORT_ARG     = 0;
my $VERBOSE	   = 0;
my $GETTEXT_PACKAGE = "";
my $OUTPUT_FILE    = "";

my @languages;
my %varhash = ();
my %po_files_by_lang = ();

# Regular expressions to categorize file types.
# FIXME: Please check if the following is correct

my $xml_extension =
"xml(\.in)*|".		# .in is not required
"ui|".
"lang|".
"glade2?(\.in)*|".	# .in is not required
"scm(\.in)*|".		# .in is not required
"oaf(\.in)+|".
"etspec|".
"server(\.in)+|".
"sheet(\.in)+|".
"schemas(\.in)+|".
"pong(\.in)+";

my $ini_extension =
"desktop(\.in)+|".
"caves(\.in)+|". 
"directory(\.in)+|".
"soundlist(\.in)+|".
"keys(\.in)+|".
"theme(\.in)+";

## Always flush buffer when printing
$| = 1;

## Handle options
GetOptions 
(
 "help" 	       => \$HELP_ARG,
 "version" 	       => \$VERSION_ARG,
 "dist|d"	       => \$DIST_ARG,
 "pot|p"	       => \$POT_ARG,
 "headers|s"	       => \$HEADERS_ARG,
 "maintain|m"	       => \$MAINTAIN_ARG,
 "report|r"	       => \$REPORT_ARG,
 "verbose|x"	       => \$VERBOSE,
 "gettext-package|g=s" => \$GETTEXT_PACKAGE,
 "output-file|o=s"     => \$OUTPUT_FILE,
 ) or &print_error_invalid_option;

&print_help if $HELP_ARG;
&print_version if $VERSION_ARG;

my $arg_count = ($DIST_ARG > 0)
    + ($POT_ARG > 0)
    + ($HEADERS_ARG > 0)
    + ($MAINTAIN_ARG > 0)
    + ($REPORT_ARG > 0);

&print_help if $arg_count > 1;

# --version and --help don't require a module name
my $MODULE = $GETTEXT_PACKAGE || &find_package_name;

if ($POT_ARG)
{
    &generate_headers;
    &generate_po_template;
}
elsif ($HEADERS_ARG)
{
    &generate_headers;
}
elsif ($MAINTAIN_ARG)
{
    &find_leftout_files;
}
elsif ($REPORT_ARG)
{
    &generate_headers;
    &generate_po_template;
    &print_report;
}
elsif ((defined $ARGV[0]) && $ARGV[0] =~ /^[a-z]/)
{
    my $lang = $ARGV[0];

    ## Report error if the language file supplied
    ## to the command line is non-existent
    &print_error_not_existing("$lang.po") if ! -s "$lang.po";

    if (!$DIST_ARG)
    {
	print "Working, please wait..." if $VERBOSE;
	&generate_headers;
	&generate_po_template;
    }
    &update_po_file ($lang, $OUTPUT_FILE);
    &print_status ($lang, $OUTPUT_FILE);
} 
else 
{
    &print_help;
}

exit;

#########

sub print_version
{
    print <<_EOF_;
${PROGRAM} (${PACKAGE}) $VERSION
Written by Kenneth Christiansen, Maciej Stachowiak, and Darin Adler.

Copyright (C) 2000-2003 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
_EOF_
    exit;
}

sub print_help
{
    print <<_EOF_;
Usage: ${PROGRAM} [OPTION]... LANGCODE
Updates PO template files and merge them with the translations.

Mode of operation (only one is allowed):
  -p, --pot                   generate the PO template only
  -s, --headers               generate the header files in POTFILES.in
  -m, --maintain              search for left out files from POTFILES.in
  -r, --report                display a status report for the module
  -d, --dist                  merge LANGCODE.po with existing PO template

Extra options:
  -g, --gettext-package=NAME  override PO template name, useful with --pot
  -o, --output-file=FILE      write merged translation to FILE
  -x, --verbose               display lots of feedback
      --help                  display this help and exit
      --version               output version information and exit

Examples of use:
${PROGRAM} --pot    just create a new PO template
${PROGRAM} xy       create new PO template and merge xy.po with it

Report bugs to http://bugzilla.gnome.org/ (product name "$PACKAGE")
or send email to <xml-i18n-tools\@gnome.org>.
_EOF_
    exit;
}

sub determine_type ($) 
{
   my $type = $_;
   my $gettext_type;

   # FIXME: Use $xml_extension, and maybe do all this even nicer
   my $xml_regex = 
       "(?:xml(\.in)*|ui|lang|oaf(?:\.in)+|server(?:\.in)+|sheet(?:\.in)+|".
       "pong(?:\.in)+|etspec|schemas(?:\.in)+)";
   my $ini_regex =
       "(?:desktop(?:\.in)+|theme(?:\.in)+|caves(?:\.in)+|directory(?:\.in)+|".
       "soundlist(?:\.in)+)";

   if ($type =~ /\[type: gettext\/([^\]].*)]/) 
   {
	$gettext_type=$1;
   }
   elsif ($type =~ /schemas(\.in)+$/) 
   {
	$gettext_type="schemas";
   }
   elsif ($type =~ /$xml_regex$/) 
   {
       $gettext_type="xml";
   }
   elsif ($type =~ /glade2?(\.in)*$/) 
   {
       $gettext_type="glade";
   }
   elsif ($type =~ /$ini_regex$/) 
   { 
       $gettext_type="ini";
   }
   elsif ($type =~ /scm(\.in)*$/) 
   {
       $gettext_type="scheme";
   }
   elsif ($type =~ /keys(\.in)+$/) 
   {
       $gettext_type="keys";
   }
   else 
   { 
       $gettext_type=""; 
   }

   return "gettext\/$gettext_type";
}

sub determine_code ($) 
{
    my $gettext_code="ASCII"; # All files are ASCII by default
    my $filetype=`file $_ | cut -d ' ' -f 2`;

    if ($? eq "0")
    {
	if ($filetype =~ /^(ISO|UTF)/)
	{
	    chomp ($gettext_code = $filetype);
	}
	elsif ($filetype =~ /^XML/)
	{
	    $gettext_code="UTF-8"; # We asume that .glade and other .xml files are UTF-8
	}
    }

    return $gettext_code;
}


sub find_leftout_files
{
    my (@buf_i18n_plain,
	@buf_i18n_xml,
	@buf_i18n_xml_unmarked,
	@buf_i18n_ini,
	@buf_potfiles,
	@buf_potfiles_ignore,
	@buf_allfiles,
	@buf_allfiles_sorted,
	@buf_potfiles_sorted
    );

    ## Search and find all translatable files
    find sub { 
	push @buf_i18n_plain,        "$File::Find::name" if /\.(c|y|cc|cpp|c\+\+|h|gob)$/;
	push @buf_i18n_xml,          "$File::Find::name" if /\.($xml_extension)$/;
	push @buf_i18n_ini,          "$File::Find::name" if /\.($ini_extension)$/;
	push @buf_i18n_xml_unmarked, "$File::Find::name" if /\.(schemas(\.in)+)$/;
	}, "..";


    open POTFILES, "<POTFILES.in" or die "$PROGRAM:  there's no POTFILES.in!\n";
    @buf_potfiles = grep !/^(#|\s*$)/, <POTFILES>;
    close POTFILES;

    foreach (@buf_potfiles) {
	s/^\[.*]\s*//;
    }

    print "Searching for missing translatable files...\n" if $VERBOSE;

    ## Check if we should ignore some found files, when
    ## comparing with POTFILES.in
    foreach my $ignore ("POTFILES.skip", "POTFILES.ignore")
    {
	(-s $ignore) or next;

	if ("$ignore" eq "POTFILES.ignore")
	{
	    print "The usage of POTFILES.ignore is deprecated. Please consider moving the\n".
		  "content of this file to POTFILES.skip.\n";
	}

	print "Found $ignore: Ignoring files...\n" if $VERBOSE;
	open FILE, "<$ignore" or die "ERROR: Failed to open $ignore!\n";
	    
	while (<FILE>)
	{
	    push @buf_potfiles_ignore, $_ unless /^(#|\s*$)/;
	}
	close FILE;

	@buf_potfiles = (@buf_potfiles_ignore, @buf_potfiles);
    }

    foreach my $file (@buf_i18n_plain)
    {
	my $in_comment = 0;
	my $in_macro = 0;

	open FILE, "<$file";
	while (<FILE>)
	{
	    # Handle continued multi-line comment.
	    if ($in_comment)
	    {
		next unless s-.*\*/--;
		$in_comment = 0;
	    }

	    # Handle continued macro.
	    if ($in_macro)
	    {
		$in_macro = 0 unless /\\$/;
		next;
	    }

	    # Handle start of macro (or any preprocessor directive).
	    if (/^\s*\#/)
	    {
		$in_macro = 1 if /^([^\\]|\\.)*\\$/;
		next;
	    }

	    # Handle comments and quoted text.
	    while (m-(/\*|//|\'|\")-) # \' and \" keep emacs perl mode happy
	    {
		my $match = $1;
		if ($match eq "/*")
		{
		    if (!s-/\*.*?\*/--)
		    {
			s-/\*.*--;
			$in_comment = 1;
		    }
		}
		elsif ($match eq "//")
		{
		    s-//.*--;
		}
		else # ' or "
		{
		    if (!s-$match([^\\]|\\.)*?$match-QUOTEDTEXT-)
		    {
			warn "mismatched quotes at line $. in $file\n";
			s-$match.*--;
		    }
		}
	    }	    

	    if (/_\(QUOTEDTEXT/)
	    {
		## Remove the first 3 chars and add newline
		push @buf_allfiles, unpack("x3 A*", $file) . "\n";
		last;
	    }
	}
	close FILE;
    }

    foreach my $file (@buf_i18n_xml) 
    {
	open FILE, "<$file";
	
	while (<FILE>) 
	{
	    # FIXME: share the pattern matching code with intltool-extract
	    if (/\s_(.*)=\"/ || /<_[^>]+>/ || /translatable=\"yes\"/)
	    {
		push @buf_allfiles, unpack("x3 A*", $file) . "\n";
		last;
	    }
	}
	close FILE;
    }

    foreach my $file (@buf_i18n_ini)
    {
	open FILE, "<$file";
	while (<FILE>) 
	{
	    if (/_(.*)=/)
	    {
		push @buf_allfiles, unpack("x3 A*", $file) . "\n";
		last;
	    }
	}
	close FILE;
    }

    foreach my $file (@buf_i18n_xml_unmarked)
    {
	push @buf_allfiles, unpack("x3 A*", $file) . "\n";
    }


    @buf_allfiles_sorted = sort (@buf_allfiles);
    @buf_potfiles_sorted = sort (@buf_potfiles);

    my %in2;
    foreach (@buf_potfiles_sorted) 
    {
	$in2{$_} = 1;
    }

    my @result;

    foreach (@buf_allfiles_sorted)
    {
	if (!exists($in2{$_}))
	{
	    push @result, $_
	}
    }

    my @buf_potfiles_notexist;

    foreach (@buf_potfiles_sorted)
    {
	chomp (my $dummy = $_);
	if ("$dummy" ne "" and ! -f "../$dummy")
	{
	    push @buf_potfiles_notexist, $_;
	}
    }

    ## Save file with information about the files missing
    ## if any, and give information about this procedure.
    if (@result + @buf_potfiles_notexist > 0)
    {
	if (@result) 
	{
	    print "\n" if $VERBOSE;
	    unlink "missing";
	    open OUT, ">missing";
	    print OUT @result;
	    close OUT;
	    warn "\e[1mThe following files contain translations and are currently not in use. Please\e[0m\n".
	         "\e[1mconsider adding these to the POTFILES.in file, located in the po/ directory.\e[0m\n\n";
	    print STDERR @result, "\n";
	    warn "If some of these files are left out on purpose then please add them to\n".
		 "POTFILES.skip instead of POTFILES.in. A file \e[1m'missing'\e[0m containing this list\n".
		 "of left out files has been written in the current directory.\n";
	}
	if (@buf_potfiles_notexist)
	{
	    unlink "notexist";
	    open OUT, ">notexist";
	    print OUT @buf_potfiles_notexist;
	    close OUT;
	    warn "\n" if ($VERBOSE or @result);
	    warn "\e[1mThe following files do not exist anymore:\e[0m\n\n";
	    warn @buf_potfiles_notexist, "\n";
	    warn "Please remove them from POTFILES.in or POTFILES.skip. A file \e[1m'notexist'\e[0m\n".
		 "containing this list of absent files has been written in the current directory.\n";
	}
    }

    ## If there is nothing to complain about, notify the user
    else {
	print "\nAll files containing translations are present in POTFILES.in.\n" if $VERBOSE;
    }
}

sub print_error_invalid_option
{
    ## Handle invalid arguments
    print STDERR "Try `${PROGRAM} --help' for more information.\n";
    exit 1;
}

sub generate_headers
{
    my $EXTRACT = `which intltool-extract 2>/dev/null`;
    chomp $EXTRACT;

    $EXTRACT = $ENV{"INTLTOOL_EXTRACT"} if $ENV{"INTLTOOL_EXTRACT"};

    ## Generate the .h header files, so we can allow glade and
    ## xml translation support
    if (! -x "$EXTRACT")
    {
	print STDERR "\n *** The intltool-extract script wasn't found!"
	     ."\n *** Without it, intltool-update can not generate files.\n";
	exit;
    }
    else
    {
	open (FILE, "<POTFILES.in") or die "$PROGRAM: POTFILES.in not found.\n";
	
	while (<FILE>) 
	{
	   chomp;
	   next if /^\[\s*encoding/;

	   ## Find xml files in POTFILES.in and generate the
	   ## files with help from the extract script

	   my $gettext_type= &determine_type ($1);

	   if (/\.($xml_extension|$ini_extension)$/ || /^\[/)
	   {
	       s/^\[[^\[].*]\s*//;

	       my $filename = "../$_";

	       if ($VERBOSE)
	       {
		   system ($EXTRACT, "--update", 
			   "--type=$gettext_type", $filename);
	       } 
	       else 
	       {
	 	   system ($EXTRACT, "--update", "--type=$gettext_type", 
			   "--quiet", $filename);
	       }
	   }
       }
       close FILE;
   }
}

#
# Generate .pot file from POTFILES.in
#
sub generate_po_template
{
    my $XGETTEXT = `which xgettext 2>/dev/null`;
    chomp $XGETTEXT;

    $XGETTEXT = $ENV{"XGETTEXT"} if $ENV{"XGETTEXT"};

    if (! -x $XGETTEXT)
    {
	print STDERR " *** xgettext is not found on this system!\n".
		     " *** Without it, intltool-update can not extract strings.\n";
	exit;
    }

    print "Building $MODULE.pot...\n" if $VERBOSE;

    open INFILE, "<POTFILES.in";
    unlink "POTFILES.in.temp";
    open OUTFILE, ">POTFILES.in.temp";

    my $gettext_support_nonascii = 0;

    # checks for GNU gettext >= 0.12
    # don't use argument list, since shell interpretation is desired here
    if (system("$XGETTEXT --version --from-code=UTF-8 >&/dev/null") == 0)
    {
	$gettext_support_nonascii = 1;
    }
    else
    {
	# urge everybody to upgrade gettext
	print STDERR "WARNING: This version of gettext does not support extracting non-ASCII\n".
		     "         strings. That means you should install a version of gettext\n".
		     "         that supports non-ASCII strings (such as GNU gettext >= 0.12),\n".
		     "         or have to let non-ASCII strings untranslated.\n";
    }

    my $encoding = "ASCII";
    my $forced_gettext_code;
    my @temp_headers;
    my $encoding_problem_is_reported = 0;

    while (<INFILE>) 
    {
	next if (/^#/ or /^\s*$/);

	chomp;

	my $gettext_code;

	if (/^\[\s*encoding:\s*(.*)\s*\]/)
	{
	    $forced_gettext_code=$1;
	}
	elsif (/\.($xml_extension|$ini_extension)$/ || /^\[/)
	{
	    s/^\[.*]\s*//;
	    print OUTFILE "$_.h\n";
	    push @temp_headers, "../$_.h";
	    $gettext_code = &determine_code ("../$_.h") if ($gettext_support_nonascii and not defined $forced_gettext_code);
	} 
	else 
	{
	    print OUTFILE "$_\n";
	    $gettext_code = &determine_code ("../$_") if ($gettext_support_nonascii and not defined $forced_gettext_code);
	}

	next if (! $gettext_support_nonascii);

	if (defined $forced_gettext_code)
	{
	    $encoding=$forced_gettext_code;
	}
	elsif (defined $gettext_code and "$encoding" ne "$gettext_code")
	{
	    if ($encoding eq "ASCII")
	    {
		$encoding=$gettext_code;
	    }
	    elsif ($gettext_code ne "ASCII")
	    {
		# Only report once because the message is quite long
		if (! $encoding_problem_is_reported)
		{
		    print STDERR "WARNING: You should use the same file encoding for all your project files,\n".
				 "         but $PROGRAM thinks that most of the source files are in\n".
				 "         $encoding encoding, while \"$_\" is (likely) in\n".
		       		 "         $gettext_code encoding. If you are sure that all translatable strings\n".
				 "         are in same encoding (say UTF-8), please \e[1m*prepend*\e[0m the following\n".
				 "         line to POTFILES.in:\n\n".
				 "                 [encoding: UTF-8]\n\n".
				 "         and make sure that configure.in/ac checks for $PACKAGE >= 0.27 .\n".
				 "(such warning message will only be reported once.)\n";
		    $encoding_problem_is_reported = 1;
		}
	    }
	}
    }

    close OUTFILE;
    close INFILE;

    unlink "$MODULE.pot";
    my @xgettext_argument=("$XGETTEXT",
			   "--add-comments",
			   "--directory\=\.\.",
			   "--keyword\=\_",
			   "--keyword\=N\_",
			   "--keyword\=U\_",
			   "--output\=$MODULE\.pot",
			   "--files-from\=\.\/POTFILES\.in\.temp");
    push @xgettext_argument, "--from-code\=$encoding" if ($gettext_support_nonascii);
    my $xgettext_command = join ' ', @xgettext_argument;

    # intercept xgettext error message
    my $xgettext_error_msg = `$xgettext_command 2>\&1`;
    my $command_failed = $?;

    unlink "POTFILES.in.temp";

    print "Removing generated header (.h) files..." if $VERBOSE;
    unlink foreach (@temp_headers);
    print "done.\n" if $VERBOSE;

    if (! $command_failed)
    {
	if (! -e "$MODULE.pot")
	{
	    print "None of the files in POTFILES.in contain strings marked for translation.\n" if $VERBOSE;
	}
	else
	{
	    print "Wrote $MODULE.pot\n" if $VERBOSE;
	}
    }
    else
    {
	if ($xgettext_error_msg =~ /--from-code/)
	{
	    # replace non-ASCII error message with a more useful one.
	    print STDERR "ERROR: xgettext failed to generate PO template file because there is non-ASCII\n".
			 "       string marked for translation. Please make sure that all strings marked\n".
			 "       for translation are in uniform encoding (say UTF-8), then \e[1m*prepend*\e[0m the\n".
			 "       following line to POTFILES.in and rerun $PROGRAM:\n\n".
			 "           [encoding: UTF-8]\n\n";
	}
	else
	{
	    print STDERR "$xgettext_error_msg";
	    if (-e "$MODULE.pot")
	    {
		# is this possible?
		print STDERR "ERROR: xgettext failed but still managed to generate PO template file.\n".
			     "       Please consult error message above if there is any.\n";
	    }
	    else
	    {
		print STDERR "ERROR: xgettext failed to generate PO template file. Please consult\n".
			     "       error message above if there is any.\n";
	    }
	}
	exit (1);
    }
}

sub update_po_file
{
    -f "$MODULE.pot" or die "$PROGRAM: $MODULE.pot does not exist.\n";

    my ($lang, $outfile) = @_;

    print "Merging $lang.po with $MODULE.pot..." if $VERBOSE;

    my $infile = "$lang.po";
    $outfile = "$lang.po" if ($outfile eq "");

    # I think msgmerge won't overwrite old file if merge is not successful
    system ("msgmerge", "-o", $outfile, $infile, "$MODULE.pot");
}

sub print_error_not_existing
{
    my ($file) = @_;

    ## Report error if supplied language file is non-existing
    print STDERR "$PROGRAM: $file does not exist!\n";
    print STDERR "Try '$PROGRAM --help' for more information.\n";
    exit;
}

sub gather_po_files
{
    my @po_files = glob ("./*.po");

    @languages = map (&po_file2lang, @po_files);

    foreach my $lang (@languages) 
    {
	$po_files_by_lang{$lang} = shift (@po_files);
    }
}

sub po_file2lang ($)
{
    s/^(.*\/)?(.+)\.po$/$2/;
    return $_;
}

sub print_status
{
    my ($lang, $output_file) = @_;

    $output_file = "$lang.po" if ($output_file eq "");

    system ("msgfmt", "-o", "/dev/null", "--statistics", $output_file);
}

sub print_report
{
    &gather_po_files;

    foreach my $lang (@languages) 
    {
	print "$lang: ";
	&update_po_file ($lang, "");
    }

    print "\n\n * Current translation support in $MODULE \n\n";

    foreach my $lang (@languages)
    {
	print "$lang: ";
	system ("msgfmt", "-o", "/dev/null", "--statistics", "$lang.po");
    }
}

sub substitute_var
{
    my ($str) = @_;
    
    # always need to rewind file whenever it has been accessed
    seek (CONF, 0, 0);

    # cache each variable. varhash is global to we can add
    # variables elsewhere.
    while (<CONF>)
    {
	if (/^(\w+)=(\S+)/)
	{
	    $varhash{$1} = $2;
	}
    }
    
    if ($str =~ /^(.*)\${?([A-Z_]+)}?(.*)$/)
    {
	my $rest = $3;
	my $untouched = $1;
	my $sub = $varhash{$2};
	
	return substitute_var ("$untouched$sub$rest");
    }
    return $str;
}

sub open_CONF_handle
{
    my $base_dirname = getcwd();
    $base_dirname =~ s@.*/@@;

    my ($conf_in, $src_dir);

    if ($base_dirname =~ /^po(-.+)?$/) 
    {
	if (-f "../configure.ac") 
	{
	    $conf_in = "../configure.ac";
	} 
	elsif (-f "../configure.in") 
	{
	    $conf_in = "../configure.in";
	} 
	else 
	{
	    my $makefile_source;

	    local (*IN);
	    open IN, "<Makefile" || die "can't open Makefile: $!";

	    while (<IN>) 
	    {
		if (/^top_srcdir[ \t]*=/) 
		{
		    $src_dir = $_;		    
		    $src_dir =~ s/^top_srcdir[ \t]*=[ \t]*([^ \t\n\r]*)/$1/;

		    chomp $src_dir;
		    $conf_in = "$src_dir" . "/configure.in" . "\n";

		    last;
		}
	    }
	    close IN;

	    $conf_in || die "Cannot find top_srcdir in Makefile.";
	}

	open (CONF, "<$conf_in") || die "can't open $conf_in: $!";
    }
    else
    {
	print STDERR "$PROGRAM: Unable to proceed.\n" .
		     "Make sure to run this script inside the po directory.\n";
	exit;
    }
}

sub find_package_name
{
    &open_CONF_handle;

    my $conf_source; {
	local (*IN);
	open (IN, "<&CONF") || die "can't open configure.in/configure.ac: $!";
	seek (IN, 0, 0);
	local $/; # slurp mode
	$conf_source = <IN>;
	close IN;
    }

    my $name = "untitled";
    my $version;

    # priority for getting package name:
    # 1. GETTEXT_PACKAGE
    # 2. first argument of AC_INIT (with >= 2 arguments)
    # 3. first argument of AM_INIT_AUTOMAKE (with >= 2 argument)

    # /^AM_INIT_AUTOMAKE\([\s\[]*([^,\)\s\]]+)/m 
    # the \s makes this not work, why?
    if ($conf_source =~ /^AM_INIT_AUTOMAKE\(([^,\)]+),([^,\)]+)/m)
    {
	($name, $version) = ($1, $2);
	$name =~ s/[\[\]\s]//g;
	($varhash{"AC_PACKAGE_VERSION"} = $version) =~ s/[\[\]\s]//g;
    }
    
    if ($conf_source =~ /^AC_INIT\(([^,\)]+),([^,\)]+)/m) 
    {
	($name, $version) = ($1, $2);
	$name=~ s/[\[\]\s]//g;
	$varhash{"AC_PACKAGE_NAME"} = $name;
	($varhash{"AC_PACKAGE_VERSION"} = $version) =~ s/[\[\]\s]//g;
    }

    # \s makes this not work, why?
    $name = $1 if $conf_source =~ /^GETTEXT_PACKAGE=\[?([^\n\]]+)/m;
    
    # prepend '$' to auto* internal variables, usually they are
    # used in configure.in/ac without the '$'
    $name =~ s/AC_/\$AC_/g;
    $name =~ s/\$\$/\$/g;
    
    $name = substitute_var ($name);

    return $name if $name;
}
