requires 2.0.10

%ph{
#include "main.h"
#include "misc.h"
typedef struct _GmpcSignal{
    guint id;
    gpointer data;
    GSourceFunc func;
}GmpcSignal;
%}

%ht{
#include <gtk/gtk.h>
#include <libmpd/libmpd.h>
%}

class Gmpc:Idle from G:Object
{
    private GList *signals = {NULL};
    private guint idle_id = 0;
    private guint last_id = 0;

    private 
    gboolean
    idle_handler(self)
    {
        GList *first = g_list_first(self->_priv->signals);
        if(first)
        {
            GmpcSignal *gs = first->data;
            self->_priv->signals = g_list_delete_link(self->_priv->signals, first);
            gs->func(gs->data);
            g_free(gs);
        }
        if(self->_priv->signals)
        {
            return TRUE;
        }
        self->_priv->idle_id = 0;
        return FALSE;
    }

    public
    void
    source_remove(self,guint id)
    {
        GList *first = g_list_first(self->_priv->signals);
        for(;first;first = g_list_next(first))
        {
            GmpcSignal *gs = first->data;
            if(gs->id == id)
            {
                self->_priv->signals = g_list_delete_link(self->_priv->signals, first);
                printf("remove signal: %i\n", id);
                g_free(gs);
                return;
            }
        }
    }
    public
    guint
    add(self, GSourceFunc func, gpointer data)
    {
        GmpcSignal *gs = g_malloc0(sizeof(*gs));
        gs->id = self->_priv->last_id;
        self->_priv->last_id++;
        gs->data = data;
        gs->func = func;
        self->_priv->signals = g_list_append(self->_priv->signals, gs);
        if(self->_priv->idle_id == 0)
        {
            self->_priv->idle_id = g_idle_add(self_idle_handler, self);
        }
        return gs->id;
    }


    /* Constructor */
    public
    GmpcIdle *
    new(void)
    {
        Self *self = GET_NEW;

        return self;
    }
    override (G:Object)
    void
    finalize(G:Object *obj)
    {
        Self *self = SELF(obj);
        if(self->_priv->idle_id)
        {
            g_source_remove(self->_priv->idle_id);
            self->_priv->idle_id = 0;
        }
        if(self->_priv->signals)
        {
            g_list_foreach(self->_priv->signals,(GFunc)g_free,NULL);
            g_list_free(self->_priv->signals);
            self->_priv->signals = NULL;

        }
        PARENT_HANDLER(obj);
    }


}
