requires 2.0.0

%headertop{
#include <gtk/gtk.h>
#include <libmpd/libmpd.h>
#include "main.h"
#include "misc.h"
%}

class Gmpc:Meta:Text:View from Gtk:Text:View {
	private GtkTextBuffer *buffer 	= {gtk_text_buffer_new(NULL)} destroywith g_object_unref;
	private mpd_Song *song 			= {NULL} destroywith mpd_freeSong;
	private int type 				= {META_ARTIST_TXT};
	private guint meta_id 			= {0};

	init (self)
	{
		gtk_text_view_set_buffer(GTK_TEXT_VIEW(self), self->_priv->buffer);
		gtk_text_view_set_editable(GTK_TEXT_VIEW(self), FALSE);
		gtk_text_view_set_wrap_mode(GTK_TEXT_VIEW(self), GTK_WRAP_WORD);
		g_signal_connect(G_OBJECT(self), "populate-popup", G_CALLBACK(self_menu_populate_callback), NULL);
		self->_priv->meta_id= g_signal_connect(G_OBJECT(gmw), "data-changed", G_CALLBACK(self_meta_callback), self);
	}
	
	public 
	GtkWidget * new (int type)
	{
		Self *gmi =  GET_NEW;
		gmi->_priv->type = type;
		return (GtkWidget *)gmi;
	}

	private 
	void
	menu_populate_callback(self, GtkMenu *menu, gpointer data)
	{
		if(self->_priv->song)
		{
			GtkWidget *item = gtk_separator_menu_item_new();
			gtk_menu_shell_append(GTK_MENU_SHELL(menu), item);
			gtk_widget_show(item);
			item = gtk_image_menu_item_new_with_label(_("Refetch"));
			gtk_image_menu_item_set_image(GTK_IMAGE_MENU_ITEM(item), gtk_image_new_from_stock(GTK_STOCK_REFRESH, GTK_ICON_SIZE_MENU));
			g_signal_connect_swapped(G_OBJECT(item), "activate", G_CALLBACK(self_query_refetch),self);
			gtk_menu_shell_append(GTK_MENU_SHELL(menu), item);
			gtk_widget_show(item);
		}
	}

	public 
	void
	query_refetch(self)
	{
		if(self->_priv->song)
		{
			gchar *path = NULL;
			MetaDataResult ret;
			ret = gmpc_meta_watcher_get_meta_path(gmw,self->_priv->song, self->_priv->type|META_QUERY_NO_CACHE, &path);
			if(ret == META_DATA_FETCHING)
			{
				self_set_text_fetching(self);
			}else if (ret == META_DATA_AVAILABLE) {
				self_set_text_from_path(self,path); 
			} else {
				self_set_text_na(self);
			}
			if(path)
			{
				q_free(path);
			}
		}
	}

	public 
	void
	query_text_from_song(self, mpd_Song *song)
	{
		if(self->_priv->song)
		{
			mpd_freeSong(self->_priv->song);
		}
		self->_priv->song = mpd_songDup(song);
	gchar *path = NULL;
			MetaDataResult ret;
			ret = gmpc_meta_watcher_get_meta_path(gmw,self->_priv->song, self->_priv->type, &path);
			if(ret == META_DATA_FETCHING)
			{
				self_set_text_fetching(self);
			}else if (ret == META_DATA_AVAILABLE) {
				self_set_text_from_path(self,path); 
			} else {
				self_set_text_na(self);
			}
			if(path)
			{
				q_free(path);
			}
	}

	signal last NONE (STRING)	
	void
	set_text_from_path(self, gchar *path)
	{
		gchar *content=NULL;
		gsize size = 0;
		if(g_file_get_contents (path,&content,&size,NULL))
		{
			gtk_text_buffer_set_text(self->_priv->buffer, content, size);
			g_free(content);
		}
	}
	
	signal last NONE (NONE)	
	void
	set_text_fetching(self)
	{
		if(self->_priv->type == META_SONG_TXT)
		{
			gtk_text_buffer_set_text(GTK_TEXT_BUFFER(self->_priv->buffer), _("Fetching Lyric"),-1);
		}
		else if (self->_priv->type == META_ARTIST_TXT)
		{
			gtk_text_buffer_set_text(GTK_TEXT_BUFFER(self->_priv->buffer), _("Fetching Artist Info"),-1);
		}
		else
		{
			gtk_text_buffer_set_text(GTK_TEXT_BUFFER(self->_priv->buffer), _("Fetching Album Info"),-1);
		}
	}

	signal last NONE (NONE)	
	void
	set_text_na(self)
	{
		gtk_text_buffer_set_text(GTK_TEXT_BUFFER(self->_priv->buffer), _("Not Available"),-1);
	}

	private
	void
	meta_callback(GmpcMetaWatcher *gmw , mpd_Song *song,  MetaDataType type, MetaDataResult ret, char *path,gpointer data)
	{
		Self *self = data;
		/**
		 * Check for fields
		 */
		if(self->_priv->type != type)
			return;

		if(!gmpc_meta_watcher_match_data(self->_priv->type, self->_priv->song, song))
		{
			printf("not for me\n");
			return;
		}


		if(ret == META_DATA_AVAILABLE) {
			self_set_text_from_path(self,path); 
			self->_priv->meta_id = 0;
		} else if (ret == META_DATA_FETCHING) {
			self_set_text_fetching(self);
		} else {
			self_set_text_na(self);
			self->_priv->meta_id = 0;
		}
	}

	override (G:Object)
		void 
		finalize (G:Object *obj)
		{
			Self *self = GMPC_META_TEXT_VIEW(obj); 
			printf("%i\n", self->_priv->meta_id);
			if(self->_priv->meta_id)
			{
				g_signal_handler_disconnect(G_OBJECT(gmw),self->_priv->meta_id);
				self->_priv->meta_id =  0;
			}
		}
}
