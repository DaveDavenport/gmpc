/* Gnome Music Player Client (GMPC)
 * Copyright (C) 2004-2009 Qball Cow <qball@sarine.nl>
 * Project homepage: http://gmpcwiki.sarine.nl/
 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.

 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.

 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
*/

requires 2.0.0

%headertop{
#include <gtk/gtk.h>
#include <libmpd/libmpd.h>
#include "main.h"
#include "misc.h"
%}

class Gmpc:Meta:Text:View from Gtk:Text:View {
	private GtkTextBuffer *buffer 	= {gtk_text_buffer_new(NULL)} unrefwith g_object_unref;
	private mpd_Song *song 			= {NULL} destroywith mpd_freeSong;
	private int type 				= {META_ARTIST_TXT};
	private gulong meta_id 			= {0};

	init (self)
	{
		gtk_text_view_set_buffer(GTK_TEXT_VIEW(self), self->_priv->buffer);
		gtk_text_view_set_editable(GTK_TEXT_VIEW(self), FALSE);
		gtk_text_view_set_wrap_mode(GTK_TEXT_VIEW(self), GTK_WRAP_WORD);
		g_signal_connect(G_OBJECT(self), "populate-popup", G_CALLBACK(self_menu_populate_callback), NULL);
		self->_priv->meta_id= g_signal_connect(G_OBJECT(gmw), "data-changed", G_CALLBACK(self_meta_callback), self);
	}
	
	public 
	GtkWidget * new (int type)
	{
		Self *gmi =  GET_NEW;
		gmi->_priv->type = type;
		return (GtkWidget *)gmi;
	}

	private 
	void
	menu_populate_callback(self, GtkMenu *menu, gpointer data)
	{
		if(self->_priv->song)
		{
			GtkWidget *item = gtk_separator_menu_item_new();
			gtk_menu_shell_append(GTK_MENU_SHELL(menu), item);


			item = gtk_image_menu_item_new_with_label(_("Refetch"));
			gtk_image_menu_item_set_image(GTK_IMAGE_MENU_ITEM(item), gtk_image_new_from_stock(GTK_STOCK_REFRESH, GTK_ICON_SIZE_MENU));
			g_signal_connect_swapped(G_OBJECT(item), "activate", G_CALLBACK(self_query_refetch),self);
			gtk_menu_shell_append(GTK_MENU_SHELL(menu), item);

			item = gtk_image_menu_item_new_with_label(_("Select file"));
			gtk_image_menu_item_set_image(GTK_IMAGE_MENU_ITEM(item), gtk_image_new_from_stock(GTK_STOCK_OPEN, GTK_ICON_SIZE_MENU));
			g_signal_connect_swapped(G_OBJECT(item), "activate", G_CALLBACK(self_select_file),self);
			gtk_menu_shell_append(GTK_MENU_SHELL(menu), item);

			item = gtk_image_menu_item_new_from_stock(GTK_STOCK_CLEAR, NULL);
			g_signal_connect_swapped(G_OBJECT(item), "activate", G_CALLBACK(self_clear_entry),self);
			gtk_menu_shell_append(GTK_MENU_SHELL(menu), item);

			gtk_widget_show_all(GTK_WIDGET(menu));
		}
	}

	public 
	void
	query_refetch(self)
	{
		if(self->_priv->song)
		{
			gchar *path = NULL;
			MetaDataResult ret;
			ret = gmpc_meta_watcher_get_meta_path(gmw,self->_priv->song, self->_priv->type|META_QUERY_NO_CACHE, &path);
			if(ret == META_DATA_FETCHING)
			{
				self_set_text_fetching(self);
			}else if (ret == META_DATA_AVAILABLE) {
				self_set_text_from_path(self,path); 
			} else {
				self_set_text_na(self);
			}
			if(path)
			{
				q_free(path);
			}
		}
	}

	public 
	void
	query_text_from_song(self, mpd_Song *song)
	{
		gchar *path = NULL;
		MetaDataResult ret;

		if(self->_priv->song)
		{
			mpd_freeSong(self->_priv->song);
		}
		self->_priv->song = mpd_songDup(song);
		
		
			ret = gmpc_meta_watcher_get_meta_path(gmw,self->_priv->song, self->_priv->type, &path);
			if(ret == META_DATA_FETCHING)
			{
				self_set_text_fetching(self);
			}else if (ret == META_DATA_AVAILABLE) {
				self_set_text_from_path(self,path); 
			} else {
				self_set_text_na(self);
			}
			if(path)
			{
				q_free(path);
			}
	}

	signal last NONE (STRING)	
	void
	set_text_from_path(self, gchar *path)
	{
		gchar *content=NULL;
		gsize size = 0;
		if(g_file_get_contents (path,&content,&size,NULL))
		{
			gchar *new_data = NULL;
			gsize new_size = 0;
			if(g_utf8_validate(content, size, NULL))
			{
				gtk_text_buffer_set_text(self->_priv->buffer, content, size);
			}
			else
			{
				new_data = g_locale_to_utf8(content, size, NULL, &new_size, NULL);
				if(new_data)
				{
					gtk_text_buffer_set_text(self->_priv->buffer, new_data, new_size);
					g_free(new_data);
				}
				else
				{
					new_data = g_strdup_printf("%s: '%s' %s", _("Failed to open file:"), path,_("because of encoding issues"));
					gtk_text_buffer_set_text(self->_priv->buffer,new_data,-1);
					g_free(new_data);
				}
			}
			g_free(content);
		}
	}
	
	signal last NONE (NONE)	
	void
	set_text_fetching(self)
	{
		if(self->_priv->type == META_SONG_TXT)
		{
			gtk_text_buffer_set_text(GTK_TEXT_BUFFER(self->_priv->buffer), _("Fetching Lyric"),-1);
		}
		else if (self->_priv->type == META_ARTIST_TXT)
		{
			gtk_text_buffer_set_text(GTK_TEXT_BUFFER(self->_priv->buffer), _("Fetching Artist Info"),-1);
		}
		else
		{
			gtk_text_buffer_set_text(GTK_TEXT_BUFFER(self->_priv->buffer), _("Fetching Album Info"),-1);
		}
	}

	signal last NONE (NONE)	
	void
	set_text_na(self)
	{
		gtk_text_buffer_set_text(GTK_TEXT_BUFFER(self->_priv->buffer), _("Not Available"),-1);
	}

	private
	void
	meta_callback(GmpcMetaWatcher *mw , mpd_Song *song,  MetaDataType type, MetaDataResult ret, char *path,gpointer data)
	{
		Self *self = data;
		/**
		 * Check for fields
		 */
		if(self->_priv->type != type)
			return;

		if(!gmpc_meta_watcher_match_data(self->_priv->type, self->_priv->song, song))
		{
			return;
		}
		if(ret == META_DATA_AVAILABLE) {
			self_set_text_from_path(self,path); 
		} else if (ret == META_DATA_FETCHING) {
			self_set_text_fetching(self);
		} else {
			self_set_text_na(self);
		}
	}
	override (G:Object)
	void
	finalize (G:Object *obj)
	{

		PARENT_HANDLER(obj);
	}
	override (G:Object)
	void 
	dispose (G:Object *obj)
	{
		Self *self = GMPC_META_TEXT_VIEW(obj); 
		if(self->_priv->meta_id)
		{
			g_signal_handler_disconnect(G_OBJECT(gmw),self->_priv->meta_id);
			self->_priv->meta_id =  0;
		}

		PARENT_HANDLER(obj);
	}
	public 
	void
	clear_entry(self)
	{
		meta_data_set_cache(self->_priv->song,self->_priv->type, META_DATA_UNAVAILABLE, NULL); 
		gmpc_meta_watcher_data_changed(gmw, self->_priv->song, self->_priv->type, META_DATA_UNAVAILABLE, NULL);
	}
	public
	void
	select_file(self)
	{
		mpd_Song *song = mpd_songDup(self->_priv->song);
		MetaDataType type = self->_priv->type;
		GtkFileFilter *gff = gtk_file_filter_new();
		GtkWidget *fcd = gtk_file_chooser_dialog_new(_("Select File"),NULL,
					 GTK_FILE_CHOOSER_ACTION_OPEN,
				      GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL,
				      GTK_STOCK_OPEN, GTK_RESPONSE_ACCEPT,
				      NULL);
		gtk_file_filter_set_name(gff, _("Text Document"));
		gtk_file_filter_add_mime_type(gff, "text/plain");
		gtk_file_chooser_add_filter(GTK_FILE_CHOOSER(fcd), gff);   
		gff = gtk_file_filter_new();
		gtk_file_filter_set_name(gff, _("All"));
		gtk_file_filter_add_pattern(gff, "*");
		gtk_file_chooser_add_filter(GTK_FILE_CHOOSER(fcd), gff);   

		gtk_widget_show_all(fcd);
		switch(gtk_dialog_run(GTK_DIALOG(fcd)))
		{
			case GTK_RESPONSE_ACCEPT:
				{	
					gchar *filename = gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(fcd));
					meta_data_set_cache(song,type, META_DATA_AVAILABLE, filename); 
					gmpc_meta_watcher_data_changed(gmw, song, type, META_DATA_AVAILABLE, filename);

					g_free(filename);
				}
			default:
				break;
		} 
		gtk_widget_destroy(fcd);
		mpd_freeSong(song);

	}
}
