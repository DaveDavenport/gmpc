/* Gnome Music Player Client (GMPC)
 * Copyright (C) 2004-2009 Qball Cow <qball@sarine.nl>
 * Project homepage: http://gmpcwiki.sarine.nl/
 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.

 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.

 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
*/

requires 2.0.0

%ph{
#include "main.h"
#include "misc.h"
#include "vala/gmpc_image.h"
%}

%headertop{
#include <gtk/gtk.h>
#include <libmpd/libmpd.h>
#ifdef GMPC_BUILD 
#include <gmpc-connection.h>
#else
#include <gmpc/gmpc-connection.h>
#endif
#define MOUSE_DISTANCE 8
%}

%{
static int num_drag_targets = 4; /* skip hyperlinks for now */
static GtkTargetEntry data_image_drag_target[] = 
{
    { "image/jpeg", 0, 0 },
    { "image/png",  0, 1 },
    { "image/gif",  0, 2 },
	{ "text/uri-list", 0, 3},
    { "_NETSCAPE_URL", 0,4},
    { "x-url/http", 0,5}
};
%}


%ph{
/**
 * Indicate the state
 */
typedef enum _GmpcMetaImageState{
	STATE_NA,
	STATE_FETCHING,
	STATE_IMAGE,
	NUM_STATES
}GmpcMetaImageState;



%}



class Gmpc:MetaImage from Gtk:Event:Box{
	private GmpcMetaImageState state = {STATE_NA};
    private int refresh = FALSE;
	private gulong status_signal = {0};
	private gulong connect_signal = {0};
	private gulong meta_id = {0};

    private gulong metadata_force_reload = {0};

	private gchar *image_url = {NULL};

	private mpd_Song *song = {NULL} destroywith mpd_freeSong;

	/* Popup */
	private GtkWidget *popup_win = {NULL};
	private guint popup_timer_id = {0};
	private int popup_w = {0};
	private int popup_h = {0};
	/** Public */

	public int size = {64};
	public int image_type = {META_ALBUM_ART};
	public MpdObj *connection= {NULL};
	public gboolean hide_on_na = {FALSE};
	public gboolean squared = {TRUE};
	public gchar *no_cover_icon = {g_strdup("gmpc-no-cover")} destroywith g_free;
	public gchar *loading_cover_icon = {g_strdup("gmpc-loading-cover")} destroywith g_free;

    private gulong expose_id = {0};

	/**
	 * I want fully set/get control,so I don't use property stuff,
	 * is there a way around this?
	 */
	public gboolean is_visible = {TRUE};

	property STRING loading_cover_icon
		(nick = "Loading Cover Icon",
		blurb = "Stock icon to use when loading a cover",
		default_value = "media-loading-cover",
		export,
		link);



	property STRING no_cover_icon
		(nick = "No Cover Icon",
		blurb = "Stock icon to use when no cover is present",
		default_value = "media-no-cover",
		export,
		link);
	property INT image_type 
		(nick = "Image type",
		blurb = "Type of the image, like artist art",
		default_value = META_ALBUM_ART,
		export,
		link);
		 
	property INT size
		(nick = "Size",
		blurb = "Size of the image",
		default_value = 64,
		export,
		link);

	property BOOLEAN hide_on_na
		(nick = "HideOnNA",
		blurb = "Hide the image when not available",
		default_value = FALSE,
		export,
		link);
        /*
	property POINTER connection
		(nick = "Connection",
		blurb = "A mpdObj to check on",
		default_value = NULL,
		export,
		link);
*/
	property BOOLEAN squared
		(nick = "Squared",
			blurb = "Keep the widget squared",
			default_value = TRUE,
			export,
			link);
    public void set_connection(self, MpdObj *conn)
    {
        self->connection = conn;
        if(conn)
        {
        self->_priv->status_signal = g_signal_connect_swapped(G_OBJECT(gmpcconn), 
                "status_changed",
                G_CALLBACK(self_update_cover),
                G_OBJECT(self));

		self->_priv->connect_signal = g_signal_connect_swapped(G_OBJECT(gmpcconn), 
                "connection_changed",
                G_CALLBACK(self_connection_changed),
                G_OBJECT(self));                            		
        }
    }
	private GtkWidget *image = { (GtkWidget *)gmpc_image_new()} ;
	init (self)
	{
		gtk_event_box_set_visible_window(GTK_EVENT_BOX(self), FALSE);
		gtk_container_add(GTK_CONTAINER(self), self->_priv->image);		
		gtk_container_set_resize_mode(GTK_CONTAINER(self), GTK_RESIZE_IMMEDIATE);
		gtk_widget_show_all(GTK_WIDGET(self));

		g_signal_connect_swapped(G_OBJECT(self->_priv->image), "leave-notify-event" , G_CALLBACK(self_leave_notify_event), self);
		g_signal_connect_swapped(G_OBJECT(self->_priv->image), "enter-notify-event" , G_CALLBACK(self_enter_notify_event), self);
		g_signal_connect_swapped(G_OBJECT(self->_priv->image), "button-press-event", G_CALLBACK(self_menu_populate_callback), self);
		g_signal_connect_swapped(G_OBJECT(self->_priv->image), "motion-notify-event" , G_CALLBACK(self_motion_notify_event), self);

		self->_priv->meta_id = g_signal_connect(G_OBJECT(gmw), "data-changed", G_CALLBACK(self_meta_callback), self);
		gtk_widget_add_events(GTK_WIDGET(self->_priv->image), GDK_POINTER_MOTION_MASK);
		gtk_widget_set_no_show_all(GTK_WIDGET(self),TRUE);
	}

	private
	void
	popup_destroy(self)
	{
		if(self->_priv->popup_win)
		{
			gtk_widget_destroy(self->_priv->popup_win);
			self->_priv->popup_win = NULL;
		}
	}

	private
	void
	popup_position(self)
	{
		int x,y,xm,ym;
		GdkRectangle rect;
		int monitor;
		gdk_window_get_position(gtk_widget_get_toplevel(GTK_WIDGET(self))->window, &x,&y);
		gdk_window_get_pointer(gtk_widget_get_toplevel(GTK_WIDGET(self))->window, &xm,&ym,NULL);
		monitor = gdk_screen_get_monitor_at_point(gtk_window_get_screen(GTK_WINDOW(self->_priv->popup_win)),x+xm,y+ym);
		gdk_screen_get_monitor_geometry(gtk_window_get_screen(GTK_WINDOW(self->_priv->popup_win)),monitor, &rect);
		/* if it falls of the monitor, reposition */
		if((rect.y +y+ym+self->_priv->popup_h+MOUSE_DISTANCE) > (rect.height+rect.y))	{
			y-= self->_priv->popup_h+2*MOUSE_DISTANCE;
		}
		if((x+xm+self->_priv->popup_w+MOUSE_DISTANCE) > (rect.width+rect.x)) {
			x-= self->_priv->popup_w+2*MOUSE_DISTANCE;
		}
		gtk_window_move(GTK_WINDOW(self->_priv->popup_win),x+xm+MOUSE_DISTANCE,y+ym+MOUSE_DISTANCE);



	}
	private 
	gboolean
	popup_event(self)
	{
		self->_priv->popup_timer_id = 0;
		if(self->_priv->image_url && self->size < 250 )
		{
			GtkWidget *image = gtk_image_new();
			GdkPixbuf *pb = gdk_pixbuf_new_from_file_at_scale(self->_priv->image_url, 250,250, TRUE, NULL);

			self->_priv->popup_win = gtk_window_new(GTK_WINDOW_POPUP);
			
			
			self->_priv->popup_h = gdk_pixbuf_get_height(pb);
			self->_priv->popup_w = gdk_pixbuf_get_width(pb);

			screenshot_add_border(&pb);	
			gtk_container_add(GTK_CONTAINER(self->_priv->popup_win), image);
			gtk_image_set_from_pixbuf(GTK_IMAGE(image), pb);
			/* position the thing */
			self_popup_position(self);
			gtk_widget_show_all(self->_priv->popup_win);
			g_object_unref(pb);
		}
		return FALSE;
	}

	private 
		gboolean
		motion_notify_event(self, GdkEventMotion *event, gpointer data)	
	{
		if(self->_priv->popup_win)
		{
			self_popup_position(self);
		}

		return TRUE;
	}

	private 

		gboolean
		leave_notify_event(self, GdkEventCrossing *event, gpointer data)
		{
			if(self->_priv->popup_timer_id)
				g_source_remove(self->_priv->popup_timer_id);
			self->_priv->popup_timer_id = 0;
			self_popup_destroy(self);
			return FALSE;
		}

	private 
		gboolean
		enter_notify_event(self, GdkEventCrossing *event, gpointer data)
		{
			if(self->_priv->popup_timer_id == 0)
			{
				self->_priv->popup_timer_id = g_timeout_add_seconds(1, (GSourceFunc) self_popup_event, self);
			}
			return FALSE;
		}

	override (G:Object)
	void
	finalize (G:Object *obj)
	{
        
        
        
        
        
		PARENT_HANDLER(obj);
	}

	override (G:Object)
		void 
		dispose(G:Object *obj)
		{
			Self *self = GMPC_METAIMAGE(obj); 
            if(self->_priv->meta_id)
			{
				g_signal_handler_disconnect(G_OBJECT(gmw),self->_priv->meta_id);
				self->_priv->meta_id =  0;
			}
            if(self->_priv->metadata_force_reload)
            {
                g_signal_handler_disconnect(G_OBJECT(gmw),self->_priv->metadata_force_reload);
                self->_priv->metadata_force_reload =  0;
            }
			if(self->_priv->popup_timer_id)
			{
				g_source_remove(self->_priv->popup_timer_id);
				self->_priv->popup_timer_id=0;
			}
			if(self->_priv->image_url) {
				q_free(self->_priv->image_url);
			}
			self_popup_destroy(self);
			if(self->_priv->status_signal){
				g_signal_handler_disconnect(G_OBJECT(gmpcconn), self->_priv->status_signal);
				self->_priv->status_signal =0;
			}
			if(self->_priv->connect_signal){
				g_signal_handler_disconnect(G_OBJECT(gmpcconn), self->_priv->connect_signal);
				self->_priv->connect_signal=0;
			}
			PARENT_HANDLER(obj);
		}
    private 
        void 
        drag_data_recieved (self,
                GdkDragContext     *context,
                gint                x,
                gint                y,
                GtkSelectionData   *data,
                guint               info,
                guint               dnd_time,
                GtkWidget          *widget
                )
        {
            int found = FALSE;
            if(self->_priv->song)
            {
                if(info < num_drag_targets)
                {
                    gchar **uri =  gtk_selection_data_get_uris(data);   
                    /* Only one uri is interresting */
                    if(uri && uri[0])
                    {
                        gchar *path = g_filename_from_uri(uri[0], NULL, NULL);

                        /* try to open it */
                        if(path && gdk_pixbuf_get_file_info(path, NULL,NULL))
                        {
                            mpd_Song *song = mpd_songDup(self->_priv->song);
                            meta_data_set_cache(song,self->image_type, META_DATA_AVAILABLE, path); 
                            gmpc_meta_watcher_data_changed(gmw, song, self->image_type, META_DATA_AVAILABLE, path);
                            found = TRUE;
                            mpd_freeSong(song);
                        }
                        g_free(path);
                    }
                    g_strfreev(uri);
                }
            }

            gtk_drag_finish(context, found, FALSE, dnd_time);
        }
        /* hack to make the "delayed" image load when it gets visible"
         */
        private 
        gboolean 
        expose_event(self, GdkEventExpose *event, gpointer data)
        {
            g_signal_handler_disconnect(G_OBJECT(self), self->_priv->expose_id);
            self->_priv->expose_id = 0;
            self_update_cover_from_song_delayed_real(self);
            return FALSE;
        }

        public
        GtkWidget *new_size(int type, int size)
        {
            Self *gmi =  GET_NEW;
            gmi->image_type = type;
            gmi->size = size;

            gtk_drag_dest_set(GTK_WIDGET(gmi),
                    GTK_DEST_DEFAULT_ALL,
                    data_image_drag_target, num_drag_targets,
                    GDK_ACTION_COPY|GDK_ACTION_LINK|GDK_ACTION_DEFAULT|GDK_ACTION_MOVE);

            g_signal_connect_swapped (G_OBJECT (gmi),"drag-data-received",
                    GTK_SIGNAL_FUNC (self_drag_data_recieved),gmi);

            gmi->_priv->metadata_force_reload = g_signal_connect_swapped(G_OBJECT(gmw), "force-reload", G_CALLBACK(self_reload_image), gmi);

            return (GtkWidget *)gmi;
        }
	public 
		GtkWidget * new (int type)
		{
			Self *gmi =  GET_NEW;
			gmi->image_type = type;
            
            gtk_drag_dest_set(GTK_WIDGET(gmi),
                    GTK_DEST_DEFAULT_ALL,
                data_image_drag_target, num_drag_targets,
                GDK_ACTION_COPY|GDK_ACTION_LINK|GDK_ACTION_DEFAULT|GDK_ACTION_MOVE);
        g_signal_connect_swapped (G_OBJECT (gmi),"drag-data-received",
                GTK_SIGNAL_FUNC (self_drag_data_recieved),gmi);
            gmi->_priv->metadata_force_reload = g_signal_connect_swapped(G_OBJECT(gmw), "force-reload", G_CALLBACK(self_reload_image), gmi);
            return (GtkWidget *)gmi;
		}

	public	
		void
		update_cover(self, MpdObj *mi, ChangedStatusType what, GmpcConnection *gc)
		{

			if(self->connection && what&(MPD_CST_STATE|MPD_CST_SONGID|MPD_CST_SONGPOS|MPD_CST_PLAYLIST) && self->is_visible)
			{
				int state = mpd_player_get_state(self->connection);
				if(state == MPD_PLAYER_STOP || state == MPD_PLAYER_UNKNOWN)
				{
                    self->_priv->refresh = TRUE;
					self_set_cover_na(self);
				}
				else {
					mpd_Song *song = mpd_playlist_get_current_song(self->connection);
					if(song)
					{
                        if( self->_priv->refresh == FALSE && 
                            self->_priv->song && 
                            self->_priv->song->artist && 
                            song->artist && 
                            strcmp(song->artist, self->_priv->song->artist) == 0)
                        {
                            /* If we are artist iamge, don't update, same artist */
                            if(self->image_type == META_ARTIST_ART ) return;
                            /* If we are album, check if album matches too */
                            else if(self->image_type == META_ALBUM_ART && 
                                self->_priv->song->album && song->album &&
                                strcmp(self->_priv->song->album, song->album) == 0){
                                return;
                            }
                        }
						self_update_cover_from_song(self, song);
					}
					else
					{
						self_set_cover_na(self);
					}
                    self->_priv->refresh = FALSE;
				}

			}
            /*
			else if(self->connection && what&(MPD_CST_SONGID|MPD_CST_SONGPOS|MPD_CST_PLAYLIST) && self->is_visible)
			{
				mpd_Song *song = mpd_playlist_get_current_song(self->connection);
				if(!song)
				{
					self_set_cover_na(self);
				}
				else
				{
					self_update_cover_from_song(self, song);
				}
			}
*/
		}
	public 
		void
		connection_changed(self,MpdObj *mi, int connect, GmpcConnection *gmpconn)
		{
			if(!connect)
			{
				self_set_cover_na(self);
			}

		}

	public 
		void
		update_cover_from_song(self, mpd_Song *song)
		{
			gchar *path=  NULL;
			MetaDataResult ret;


			if(self->_priv->song)
				mpd_freeSong(self->_priv->song);
            self->_priv->song = NULL;

			if(!song)
			{
				self_set_cover_na(self);
				return;
			}
			if(self->_priv->status_signal)
				self->_priv->song = mpd_songDup(song);

			ret = gmpc_meta_watcher_get_meta_path(gmw,song, self->image_type, &path);
			if(ret == META_DATA_FETCHING)
			{
				self_set_cover_fetching(self);
			}else if (ret == META_DATA_AVAILABLE) {
					self_set_cover_from_path(self,path); 
			} else {
				self_set_cover_na(self);
			}
			if(path)
			{
				q_free(path);
			}
		}
        private
        gboolean
        update_cover_from_song_delayed_real(self)
        {
            gchar *path = NULL;
            int ret = gmpc_meta_watcher_get_meta_path(gmw,self->_priv->song, self->image_type, &path);
            if(ret == META_DATA_FETCHING)
            {
                self_set_cover_fetching(self);
            }else if (ret == META_DATA_AVAILABLE) {
                self_set_cover_from_path(self,path); 
            } else {
                self_set_cover_na(self);
            }
            if(path)
            {
                q_free(path);
            }

            return FALSE;
        }
	public 
		void
		update_cover_from_song_delayed(self, mpd_Song *song)
        {
            if(self->_priv->song)
                mpd_freeSong(self->_priv->song);
            //self_set_cover_na(self);
            gtk_widget_set_size_request(GTK_WIDGET(self), self->size, self->size);
            self->_priv->song = mpd_songDup(song);
            /* hack to make it load when it gets visible */
            self->_priv->expose_id = g_signal_connect(G_OBJECT(self), "expose-event", G_CALLBACK(self_expose_event) , NULL);
        }
		
	private
		void
		meta_callback(GmpcMetaWatcher *gmv, mpd_Song *song, MetaDataType type, MetaDataResult ret, char *path,gpointer data)
		{
			Self *self = data;
			if(!song || !self || !self->_priv || !self->_priv->song)
				return;

			
			/**
			 * Check for fields
			 */
			if(self->image_type != type)
				return;

			if(!gmpc_meta_watcher_match_data(self->image_type, self->_priv->song, song))
			{
				return;
			}

			/**
			 * If mpd is stopped before the result is back, set the cover to na, and ignore the result
			 */
			if(self->connection && mpd_player_get_state(self->connection) == MPD_PLAYER_STOP)
			{
				self_set_cover_na(self);
			}
			else
			{
				if(ret == META_DATA_AVAILABLE) {
					self_set_cover_from_path(self,path); 
				} else if (ret == META_DATA_FETCHING) {
					self_set_cover_fetching(self);
				} else {
					self_set_cover_na(self);
				}
			}
		}


	public 
		void
		set_cover_na(self)
        {
            GError *err = NULL;
            GdkPixbuf *pb2 = NULL; 

            self->_priv->state = STATE_NA;

            if(self->_priv->image_url)
            {
                q_free(self->_priv->image_url);
                self->_priv->image_url = NULL;
            }
            self_popup_destroy(self);
            if(self->hide_on_na)
            {		
                gtk_widget_hide(GTK_WIDGET(self));
                return;
            }

            if(cfg_get_single_value_as_int_with_default(config, "metaimage", "addcase",FALSE) && self->image_type == META_ALBUM_ART){
                gchar *path2 = gmpc_get_full_image_path("stylized-no-cover.svg"); 
		GdkPixbuf *pb = gdk_pixbuf_new_from_file(path2, NULL);
		if(pb)
		{
			pb2 = gdk_pixbuf_scale_simple(pb, self->size, (gdk_pixbuf_get_height(pb)*self->size)/gdk_pixbuf_get_width(pb), GDK_INTERP_HYPER);
			gdk_pixbuf_unref(pb);
		}
                g_free(path2);
            }else{
                pb2 = gtk_icon_theme_load_icon(gtk_icon_theme_get_default(), self->no_cover_icon, self->size, 0,&err);
            }
            if(!pb2)
                printf("uh owh %s\n", err->message);

            gmpc_image_set_pixbuf(GMPC_IMAGE(self->_priv->image), pb2,FALSE,FALSE);
            gtk_widget_set_size_request(GTK_WIDGET(self), self->size, self->size);
            g_object_unref(pb2);
            self_image_changed(self,META_DATA_UNAVAILABLE);
        }
	public 
		void
		set_cover_fetching(self)
		{
			GdkPixbuf *pb2 = NULL;

			self->_priv->state = STATE_FETCHING;
			if(self->_priv->image_url)
			{
				q_free(self->_priv->image_url);
				self->_priv->image_url = NULL;
			}
			self_popup_destroy(self);
			if(self->hide_on_na)
			{		
				gtk_widget_hide(GTK_WIDGET(self));
			}

                    
            if(cfg_get_single_value_as_int_with_default(config, "metaimage", "addcase",FALSE) && self->image_type == META_ALBUM_ART){
                gchar *path2 = gmpc_get_full_image_path("stylized-fetching-cover.svg"); 
		GdkPixbuf *pb = gdk_pixbuf_new_from_file(path2, NULL);
		if(pb)
		{
			pb2 = gdk_pixbuf_scale_simple(pb, self->size, (gdk_pixbuf_get_height(pb)*self->size)/gdk_pixbuf_get_width(pb), GDK_INTERP_HYPER);
			gdk_pixbuf_unref(pb);
		}
                g_free(path2);
            }else{
			  pb2 = gtk_icon_theme_load_icon(gtk_icon_theme_get_default(), self->loading_cover_icon, self->size, 0,NULL);
            }

	    gmpc_image_set_pixbuf(GMPC_IMAGE(self->_priv->image), pb2,FALSE,FALSE);
	    if(self->squared) {
                gtk_widget_set_size_request(GTK_WIDGET(self), self->size, self->size);
            }
            g_object_unref(pb2);
            self_image_changed(self,META_DATA_FETCHING);
        }

    signal last NONE (INT) 
        void 
        image_changed(self, int type)
        {
            /* do nothing */
        }

    public	
        void
        set_cover_from_path(self, gchar *path)
        {
            int width = 0; 
            int height = 0;
            GdkPixbuf *pb = NULL;

            self->_priv->state = STATE_IMAGE;
      //      pb = gdk_pixbuf_new_from_file_at_scale(path,self->size,self->size,TRUE,NULL);
            if(self->_priv->image_url)
            {
                q_free(self->_priv->image_url);
                self->_priv->image_url = NULL;
            }
            self_popup_destroy(self);

            if(gdk_pixbuf_get_file_info(path,&width, &height))
            {
               
               
                /* save url */
                self->_priv->image_url = g_strdup(path); 

                /* calculate it */
                if(width > height) {
                    height = (height*self->size)/((gdouble)width);
                    width = self->size;
                }
                else {
                    width = (width*self->size)/((gdouble)height);
                    height = self->size;
                }
                
                if(cfg_get_single_value_as_int_with_default(config, "metaimage", "addcase",FALSE) && self->image_type == META_ALBUM_ART)
                {
                    float spineRatio = 31.0/343.0;
                    int spineWidth = (width)*spineRatio;
                    GdkPixbuf *blank,*pb2 ;
                    gchar *path2;
                    /* Scale the cover to fit inside the case */
                    pb = gdk_pixbuf_new_from_file_at_scale(path,width-spineWidth, (height*(width-spineWidth))/((gdouble)width),TRUE,NULL);


                    width = gdk_pixbuf_get_width(pb)+spineWidth+0;			
                    height = gdk_pixbuf_get_height(pb)+0;
                    /* load the case */
                    path2 = gmpc_get_full_image_path("stylized-cover.svg"); 
                    blank = gdk_pixbuf_new_from_file(path2,NULL);
		    pb2 = gdk_pixbuf_scale_simple(blank, width,height, GDK_INTERP_HYPER);
		    gdk_pixbuf_unref(blank);
		    g_free(path2);
                    /* render */
                    blank = gdk_pixbuf_new(GDK_COLORSPACE_RGB, TRUE, 8,width,height);
                    gdk_pixbuf_fill(blank, 0x000000FF);
                    gdk_pixbuf_copy_area(pb, 0,0,width-spineWidth-0,height-0,blank,spineWidth+0,0);
                    gdk_pixbuf_composite(pb2,blank,0,0,width,height,0,0,1,1,GDK_INTERP_BILINEAR,250);

                    g_object_unref(pb2);
                    g_object_unref(pb);
                    pb = blank;

                    gmpc_image_set_pixbuf(GMPC_IMAGE(self->_priv->image), pb,FALSE,FALSE);
                    g_object_unref(pb);
                }
                else {
                    pb = gdk_pixbuf_new_from_file_at_scale(path,self->size,self->size,TRUE,NULL);
                    gmpc_image_set_pixbuf(GMPC_IMAGE(self->_priv->image), pb,TRUE,TRUE);
                    g_object_unref(pb);
                }
                /**
                 * Set sizing, also set size on non-squared, so the widget resizes propperly
                 */
                if(self->squared)
                {
                    gtk_widget_set_size_request(GTK_WIDGET(self), self->size, self->size);
                }
				else
                {
                    gtk_widget_set_size_request(GTK_WIDGET(self), width+2, height+2);
                }
			}
			if(self->is_visible)
			{
				gtk_widget_show(GTK_WIDGET(self));
			}
			self_image_changed(self,META_DATA_AVAILABLE);
		}

	public 
		void
		set_is_visible(self, gboolean is_visible)
		{
			self->is_visible = is_visible;
			if(self->is_visible)
			{
				if(self->connection)
				{
					self_update_cover(self,self->connection, MPD_CST_STATE, NULL);
				}
			} 
			else
			{
				gtk_widget_hide(GTK_WIDGET(self));
			}
		}
	public
		gboolean get_is_visible(self)
		{
			return self->is_visible;
		}
	public 
	void
	query_refetch(self)
	{
		if(self->_priv->song)
		{
			gchar *path = NULL;
			MetaDataResult ret;

			ret = gmpc_meta_watcher_get_meta_path(gmw,self->_priv->song, self->image_type|META_QUERY_NO_CACHE, &path);
			if(ret == META_DATA_FETCHING)
			{
				self_set_cover_fetching(self);
			}else if (ret == META_DATA_AVAILABLE) {
					self_set_cover_from_path(self,path); 
			} else {
				self_set_cover_na(self);
			}
			if(path)
			{
				q_free(path);
			}
		}
	}


	private 
	gboolean	
	menu_populate_callback(self,GdkEventButton *event,  gpointer data)
	{
		if(self->_priv->song && event->button == 3)
		{
			GtkWidget *menu = gtk_menu_new();
			GtkWidget *item = NULL; 

			item = gtk_image_menu_item_new_with_label(_("Refetch"));
			gtk_image_menu_item_set_image(GTK_IMAGE_MENU_ITEM(item), gtk_image_new_from_stock(GTK_STOCK_REFRESH, GTK_ICON_SIZE_MENU));
			g_signal_connect_swapped(G_OBJECT(item), "activate", G_CALLBACK(self_query_refetch),self);
			gtk_menu_shell_append(GTK_MENU_SHELL(menu), item);

			item = gtk_image_menu_item_new_with_label(_("Select file"));
			gtk_image_menu_item_set_image(GTK_IMAGE_MENU_ITEM(item), gtk_image_new_from_stock(GTK_STOCK_OPEN, GTK_ICON_SIZE_MENU));
			g_signal_connect_swapped(G_OBJECT(item), "activate", G_CALLBACK(self_select_file),self);
			gtk_menu_shell_append(GTK_MENU_SHELL(menu), item);

			item = gtk_image_menu_item_new_from_stock(GTK_STOCK_CLEAR, NULL);
			g_signal_connect_swapped(G_OBJECT(item), "activate", G_CALLBACK(self_clear_entry),self);
			gtk_menu_shell_append(GTK_MENU_SHELL(menu), item);

			gtk_widget_show_all(menu);
			gtk_menu_popup(GTK_MENU(menu), NULL, NULL,NULL, NULL, event->button, event->time);
			return TRUE;
		}
		return FALSE;
	}


	public 
	void
	clear_entry(self)
	{
		meta_data_set_cache(self->_priv->song,self->image_type, META_DATA_UNAVAILABLE, NULL); 
		gmpc_meta_watcher_data_changed(gmw, self->_priv->song, self->image_type, META_DATA_UNAVAILABLE, NULL);
	}
	public
	void
	select_file(self)
	{
		mpd_Song *song = mpd_songDup(self->_priv->song);
		MetaDataType type = self->image_type;
		GtkFileFilter *gff = gtk_file_filter_new();
		GtkWidget *fcd = gtk_file_chooser_dialog_new(_("Select File"),NULL,
					 GTK_FILE_CHOOSER_ACTION_OPEN,
				      GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL,
				      GTK_STOCK_OPEN, GTK_RESPONSE_ACCEPT,
				      NULL);
		gtk_file_filter_set_name(gff, _("Images"));
		gtk_file_filter_add_pixbuf_formats(gff);
		gtk_file_chooser_add_filter(GTK_FILE_CHOOSER(fcd), gff);   

		gff = gtk_file_filter_new();
		gtk_file_filter_set_name(gff, _("All"));
		gtk_file_filter_add_pattern(gff, "*");
		gtk_file_chooser_add_filter(GTK_FILE_CHOOSER(fcd), gff);   

		gtk_widget_show_all(fcd);
		switch(gtk_dialog_run(GTK_DIALOG(fcd)))
		{
			case GTK_RESPONSE_ACCEPT:
				{	
		
					gchar *filename = gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(fcd));

					meta_data_set_cache(song,type, META_DATA_AVAILABLE, filename); 
					gmpc_meta_watcher_data_changed(gmw, song, type, META_DATA_AVAILABLE, filename);

					g_free(filename);
				}
			default:
				break;
		} 
		gtk_widget_destroy(fcd);
		mpd_freeSong(song);
	}

	public
	void
	reload_image(self)
	{
		gmpc_image_clear_pixbuf(GMPC_IMAGE(self->_priv->image)); 
		switch(self->_priv->state)
		{
			case STATE_NA:
					self_set_cover_na(self);
					break;
			case STATE_FETCHING:
					self_set_cover_fetching(self);
					break;
			case STATE_IMAGE:
					{
						if(self->_priv->image_url)
						{
							gchar *temp = g_strdup(self->_priv->image_url);
							self_set_cover_from_path(self, temp);
							g_free(temp);
						}
					}
			default:
					break;
		}
	}
}
