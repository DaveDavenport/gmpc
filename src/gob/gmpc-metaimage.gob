requires 2.0.0

%headertop{
#include <gtk/gtk.h>
#include <libmpd/libmpd.h>
#include "main.h"
#include "misc.h"
#define MOUSE_DISTANCE 8
%}


class Gmpc:MetaImage from Gtk:Event:Box{
	private gulong status_signal = {0};
	private gulong connect_signal = {0};
	private guint meta_id = {0};

	private gchar *image_url = {NULL};

	private mpd_Song *song = {NULL} destroywith mpd_freeSong;

	private GtkWidget *popup_win = {NULL};
	private guint popup_timer_id = {0};
	private int popup_w = {0};
	private int popup_h = {0};
	/** Public */

	public int size = {64};
	public int image_type = {META_ALBUM_ART};
	public MpdObj *connection= {NULL};
	public gboolean hide_on_na = {FALSE};
	public gboolean draw_border = {TRUE};
	public gboolean draw_shadow = {FALSE};
	public gboolean squared = {TRUE};
	public gchar *no_cover_icon = {g_strdup("gmpc-no-cover")} destroywith g_free;
	public gchar *loading_cover_icon = {g_strdup("gmpc-loading-cover")} destroywith g_free;
	/**
	 * I want fully set/get control,so I don't use property stuff,
	 * is there a way around this?
	 */
	public gboolean is_visible = {TRUE};

	property STRING loading_cover_icon
		(nick = _("Loading Cover Icon"),
		blurb = _("Stock icon to use when loading a cover"),
		default_value = "media-loading-cover",
		export,
		link);



	property STRING no_cover_icon
		(nick = _("No Cover Icon"),
		blurb = _("Stock icon to use when no cover is present"),
		default_value = "media-no-cover",
		export,
		link);
	property INT image_type 
		(nick = _("Image type"),
		blurb = _("Type of the image, like artist art"),
		default_value = META_ALBUM_ART,
		export,
		link);
		 
	property INT size
		(nick = _("Size"),
		blurb = _("Size of the image"),
		default_value = 64,
		export,
		link);

	property BOOLEAN hide_on_na
		(nick = _("HideOnNA"),
		blurb = _("Hide the image when not availibe"),
		default_value = FALSE,
		export,
		link);
	property POINTER connection
		(nick = _("Connection"),
		blurb = _("A mpdObj to check on"),
		default_value = NULL,
		export,
		link);
	property BOOLEAN draw_border
		(nick = _("DrawBorder"),
		 blurb = _("Draw a border around the image"),
		 default_value = TRUE,
		 export,
		 link);
	property BOOLEAN draw_shadow
		(nick = _("DrawShadow"),
		 blurb = _("Draw a shadow under the image"),
		 default_value = FALSE,
		export,
		link);
	property BOOLEAN squared
		(nick = "Squared",
			blurb = "Keep the widget squared",
			default_value = TRUE,
			export,
			link);

	private GtkWidget *image = { gtk_image_new()} ;
	init (self)
	{
		gtk_event_box_set_visible_window(GTK_EVENT_BOX(self), FALSE);
		gtk_container_add(GTK_CONTAINER(self), self->_priv->image);		
		gtk_container_set_resize_mode(GTK_CONTAINER(self), GTK_RESIZE_IMMEDIATE);
		gtk_widget_show_all(GTK_WIDGET(self));
		self_set_cover_na(self);
		self->_priv->status_signal = g_signal_connect_swapped(G_OBJECT(gmpcconn), "status_changed",
				G_CALLBACK(self_update_cover), G_OBJECT(self));
		self->_priv->connect_signal = g_signal_connect_swapped(G_OBJECT(gmpcconn), "connection_changed",
				G_CALLBACK(self_connection_changed), G_OBJECT(self));                            		


		self->_priv->meta_id =  0;
		g_signal_connect(G_OBJECT(self), "leave-notify-event" , G_CALLBACK(self_leave_notify_event), NULL);
		g_signal_connect(G_OBJECT(self), "enter-notify-event" , G_CALLBACK(self_enter_notify_event), NULL);

		g_signal_connect(G_OBJECT(self), "motion-notify-event" , G_CALLBACK(self_motion_notify_event), NULL);
		gtk_widget_add_events(GTK_WIDGET(self), GDK_POINTER_MOTION_MASK);
		gtk_widget_set_no_show_all(GTK_WIDGET(self),TRUE);
	}

	private
	void
	popup_destroy(self)
	{
		if(self->_priv->popup_win)
		{
			gtk_widget_destroy(self->_priv->popup_win);
			self->_priv->popup_win = NULL;
		}
	}

	private
	void
	popup_position(self)
	{
		int x,y,xm,ym;
		GdkRectangle rect;
		int monitor;
		gdk_window_get_position(gtk_widget_get_toplevel(GTK_WIDGET(self))->window, &x,&y);
		gdk_window_get_pointer(gtk_widget_get_toplevel(GTK_WIDGET(self))->window, &xm,&ym,NULL);
		monitor = gdk_screen_get_monitor_at_point(gtk_window_get_screen(GTK_WINDOW(self->_priv->popup_win)),x+xm,y+ym);
		gdk_screen_get_monitor_geometry(gtk_window_get_screen(GTK_WINDOW(self->_priv->popup_win)),monitor, &rect);
		/* if it falls of the monitor, reposition */
		if((rect.y +y+ym+self->_priv->popup_h+MOUSE_DISTANCE) > (rect.height+rect.y))	{
			y-= self->_priv->popup_h+2*MOUSE_DISTANCE;
		}
		if((x+xm+self->_priv->popup_w+MOUSE_DISTANCE) > (rect.width+rect.x)) {
			x-= self->_priv->popup_w+2*MOUSE_DISTANCE;
		}
		gtk_window_move(GTK_WINDOW(self->_priv->popup_win),x+xm+MOUSE_DISTANCE,y+ym+MOUSE_DISTANCE);



	}
	private 
	gboolean
	popup_event(self)
	{
		self->_priv->popup_timer_id = 0;
		if(self->_priv->image_url && self->size < 250 )
		{
			self->_priv->popup_win = gtk_window_new(GTK_WINDOW_POPUP);
			GtkWidget *image = gtk_image_new();
			GdkPixbuf *pb = gdk_pixbuf_new_from_file_at_scale(self->_priv->image_url, 250,250, TRUE, NULL);
			self->_priv->popup_h = gdk_pixbuf_get_height(pb);
			self->_priv->popup_w = gdk_pixbuf_get_width(pb);
			if(self->draw_border)
				screenshot_add_border(&pb);	
			gtk_container_add(GTK_CONTAINER(self->_priv->popup_win), image);
			gtk_image_set_from_pixbuf(GTK_IMAGE(image), pb);
			/* position the thing */
			self_popup_position(self);
			gtk_widget_show_all(self->_priv->popup_win);
			g_object_unref(pb);
		}
		return FALSE;
	}

	private 
		gboolean
		motion_notify_event(self, GdkEventMotion *event, gpointer data)	
	{
		if(self->_priv->popup_win)
		{
			self_popup_position(self);
		}

		return TRUE;
	}

	private 

		gboolean
		leave_notify_event(self, GdkEventCrossing *event, gpointer data)
		{
			if(self->_priv->popup_timer_id)
				g_source_remove(self->_priv->popup_timer_id);
			self->_priv->popup_timer_id = 0;
			self_popup_destroy(self);
			return FALSE;
		}

	private 
		gboolean
		enter_notify_event(self, GdkEventCrossing *event, gpointer data)
		{
			if(self->_priv->popup_timer_id == 0)
			{
				self->_priv->popup_timer_id = g_timeout_add(1000, (GSourceFunc) self_popup_event, self);
			}
			return FALSE;
		}

	override (G:Object)
		void 
		finalize (G:Object *obj)
		{
			Self *self = GMPC_METAIMAGE(obj); 
			if(self->_priv->meta_id)
			{
				meta_data_handle_remove_request(self->_priv->meta_id);
				self->_priv->meta_id =  0;
			}
			if(self->_priv->popup_timer_id)
				g_source_remove(self->_priv->popup_timer_id);
			self->_priv->popup_timer_id=0;
			if(self->_priv->image_url) {
				q_free(self->_priv->image_url);
			}
			self_popup_destroy(self);
			if(self->_priv->status_signal){
				g_signal_handler_disconnect(G_OBJECT(gmpcconn), self->_priv->status_signal);
			}
			if(self->_priv->connect_signal){
				g_signal_handler_disconnect(G_OBJECT(gmpcconn), self->_priv->connect_signal);
			}

		}

	public 
		GtkWidget * new (int type)
		{
			Self *gmi =  GET_NEW;
			gmi->image_type = type;
			return (GtkWidget *)gmi;
		}

	public	
		void
		update_cover(self, MpdObj *mi, ChangedStatusType what, GmpcConnection *gmpcconn )
		{
			if(self->connection && what&(MPD_CST_STATE) && self->is_visible)
			{
				int state = mpd_player_get_state(mi);
				if(state == MPD_PLAYER_STOP || state == MPD_PLAYER_UNKNOWN)
				{
					self_set_cover_na(self);
				}
				else {
					mpd_Song *song = mpd_playlist_get_current_song(mi);
					if(song)
					{
						self_update_cover_from_song(self, song);
					}
					else
					{
						self_set_cover_na(self);
					}
				}

			}
			else if(self->connection && what&(MPD_CST_SONGID|MPD_CST_SONGPOS|MPD_CST_PLAYLIST) && self->is_visible)
			{
				mpd_Song *song = mpd_playlist_get_current_song(mi);
				if(!song)
				{
					self_set_cover_na(self);
				}
				else
				{
					self_update_cover_from_song(self, song);
				}
			}

		}
	public 
		void
		connection_changed(self,MpdObj *mi, int connect, GmpcConnection *gmpconn)
		{
			if(!connect)
			{
				self_set_cover_na(self);
			}

		}

	public 
		void
		update_cover_from_song(self, mpd_Song *song)
		{
			self_set_cover_na(self);
			if(self->_priv->song)
				mpd_freeSong(self->_priv->song);
			if(!song)
				return;
			if(self->_priv->status_signal)
				self->_priv->song = mpd_songDup(song);

			if(self->_priv->meta_id)
			{
				meta_data_handle_remove_request(self->_priv->meta_id);
				self->_priv->meta_id =  0;
			}
			self->_priv->meta_id = meta_data_get_path_callback(song, self->image_type, self_meta_callback, self);

		}

	private
		void
		meta_callback(mpd_Song *song, MetaDataResult ret, char *path,gpointer data)
		{
			Self *self = data;
			if(!song || !self || !self->_priv || !self->_priv->song)
				return;
			/**
			 * Check for fields
			 */
			if(song->artist == NULL || self->_priv->song->artist == NULL)
				return;
			if(self->image_type&META_ALBUM_ART && (song->album == NULL || self->_priv->song->album == NULL))
				return;
			/**
			 * match song
			 */
			if(strcmp(song->artist, self->_priv->song->artist))
				return;
			else if(self->image_type&META_ALBUM_ART && 
					strcmp(song->album, self->_priv->song->album))
				return;
			/**
			 * If mpd is stopped before the result is back, set the cover to na, and ignore the result
			 */
			else if(self->connection && mpd_player_get_state(self->connection) == MPD_PLAYER_STOP)
			{
				self_set_cover_na(self);
				if(ret != META_DATA_FETCHING)
				{
					self->_priv->meta_id = 0;
				}

			}
			else
			{
				if(ret == META_DATA_AVAILABLE) {
					self_set_cover_from_path(self,path); 
					self->_priv->meta_id = 0;
				} else if (ret == META_DATA_FETCHING) {
					self_set_cover_fetching(self);
				} else {
					self_set_cover_na(self);
					self->_priv->meta_id = 0;
				}
			}
		}


	public 
		void
		set_cover_na(self)
		{
			//GdkPixbuf *pb,*pb2; 
			GdkPixbuf *pb2; 
			if(self->_priv->image_url)
			{
				q_free(self->_priv->image_url);
				self->_priv->image_url = NULL;
			}
			self_popup_destroy(self);
			if(self->hide_on_na)
			{		
				gtk_widget_hide(GTK_WIDGET(self));
				return;
			}
        GError *err = NULL;
//			pb = gtk_widget_render_icon(GTK_WIDGET(self), self->no_cover_icon, -1, NULL);
	//		pb2=gdk_pixbuf_scale_simple(pb, self->size, self->size, GDK_INTERP_BILINEAR);
			  pb2 = gtk_icon_theme_load_icon(gtk_icon_theme_get_default(), self->no_cover_icon, self->size, 0,&err);
        if(!pb2)
          printf("uh owh %s\n", err->message);
        gtk_image_set_from_pixbuf(GTK_IMAGE(self->_priv->image), pb2);
//			if(self->squared)
				gtk_widget_set_size_request(GTK_WIDGET(self), self->size, self->size);
		//	g_object_unref(pb);
			g_object_unref(pb2);
			self_image_changed(self,META_DATA_UNAVAILABLE);
		}
	public 
		void
		set_cover_fetching(self)
		{
			//GdkPixbuf *pb,*pb2; 
			GdkPixbuf *pb2; 
			if(self->_priv->image_url)
			{
				q_free(self->_priv->image_url);
				self->_priv->image_url = NULL;
			}
			self_popup_destroy(self);
			if(self->hide_on_na)
			{		
				gtk_widget_hide(GTK_WIDGET(self));
			}
//			pb = gtk_widget_render_icon(GTK_WIDGET(self), self->loading_cover_icon, -1, NULL);
	//		pb2=gdk_pixbuf_scale_simple(pb, self->size, self->size, GDK_INTERP_BILINEAR);
			  pb2 = gtk_icon_theme_load_icon(gtk_icon_theme_get_default(), self->loading_cover_icon, self->size, 0,NULL);
        
			gtk_image_set_from_pixbuf(GTK_IMAGE(self->_priv->image), pb2);
			if(self->squared)
				gtk_widget_set_size_request(GTK_WIDGET(self), self->size, self->size);
		//	g_object_unref(pb);
			g_object_unref(pb2);
			self_image_changed(self,META_DATA_FETCHING);
		}

	signal last NONE (INT) 
		void 
		image_changed(self, int type)
		{
			/* do nothing */
		}

	public	
		void
		set_cover_from_path(self, gchar *path)
		{
			GdkPixbuf *pb = NULL;
			pb = gdk_pixbuf_new_from_file_at_scale(path,self->size-self->draw_shadow*10-2,self->size-self->draw_shadow*10-2,TRUE,NULL);
			if(self->_priv->image_url)
			{
				q_free(self->_priv->image_url);
				self->_priv->image_url = NULL;
			}
			self_popup_destroy(self);

			if(pb)
			{
				int width = 0; 
				int height = 0;
				/* save url */
				self->_priv->image_url = g_strdup(path); 

				if(self->draw_border)
					screenshot_add_border(&pb);	
				if(self->draw_shadow)
					screenshot_add_shadow(&pb);
				/** 
				 * Need to get pixbuf height/width before adding to image
				 * if added to image, somehow the returned values don't match anymore
				 */
				width = gdk_pixbuf_get_width(pb);			
				height = gdk_pixbuf_get_height(pb);
				gtk_image_set_from_pixbuf(GTK_IMAGE(self->_priv->image),pb);
				/**
				 * Set sizing, also set size on non-squared, so the widget resizes propperly
				 */
				if(self->squared)
				{
					gtk_widget_set_size_request(GTK_WIDGET(self), self->size, self->size);
				}
				else
				{
					gtk_widget_set_size_request(GTK_WIDGET(self), width+2, height+2);
				}
				g_object_unref(pb);
			}
			if(self->is_visible)
			{
				gtk_widget_show(GTK_WIDGET(self));
			}
			self_image_changed(self,META_DATA_AVAILABLE);
		}

	public 
		void
		set_is_visible(self, gboolean is_visible)
		{
			self->is_visible = is_visible;
			if(self->is_visible)
			{
				if(self->connection)
				{
					self_update_cover(self,self->connection, MPD_CST_STATE, NULL);
				}

			} 
			else
			{
				gtk_widget_hide(GTK_WIDGET(self));
			}
		}
	public
		gboolean get_is_visible(self)
		{
			return self->is_visible;
		}
}
