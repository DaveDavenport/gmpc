requires 2.0.0

%headertop{
#include <gtk/gtk.h>
#include <libmpd/libmpd.h>
#include "main.h"
#include "misc.h"
%}


class Gmpc:MetaImage from Gtk:Event:Box{
	private gulong status_signal = {0};
	private gulong connect_signal = {0};
	private guint meta_id = {0};
	private mpd_Song *song = {NULL} destroywith mpd_freeSong;
	/** Public */

	public int size = {64};
	public int image_type = {META_ALBUM_ART};
	public MpdObj *connection= {NULL};
	public gboolean hide_on_na = {FALSE};
	public gboolean draw_border = {TRUE};
	public gboolean draw_shadow = {FALSE};
	public gboolean squared = {TRUE};
	public gchar *no_cover_icon = {g_strdup("media-no-cover")} destroywith g_free;
	public gchar *loading_cover_icon = {g_strdup("media-loading-cover")} destroywith g_free;

	property STRING loading_cover_icon
		(nick = _("Loading Cover Icon"),
		blurb = _("Stock icon to use when loading a cover"),
		default_value = "media-loading-cover",
		export,
		link);



	property STRING no_cover_icon
		(nick = _("No Cover Icon"),
		blurb = _("Stock icon to use when no cover is present"),
		default_value = "media-no-cover",
		export,
		link);
	property INT image_type 
		(nick = _("Image type"),
		blurb = _("Type of the image, like artist art"),
		default_value = META_ALBUM_ART,
		export,
		link);
		 
	property INT size
		(nick = _("Size"),
		blurb = _("Size of the image"),
		default_value = 64,
		export,
		link);

	property BOOLEAN hide_on_na
		(nick = _("HideOnNA"),
		blurb = _("Hide the image when not availibe"),
		default_value = FALSE,
		export,
		link);
	property POINTER connection
		(nick = _("Connection"),
		blurb = _("A mpdObj to check on"),
		default_value = NULL,
		export,
		link);
	property BOOLEAN draw_border
		(nick = _("DrawBorder"),
		 blurb = _("Draw a border around the image"),
		 default_value = TRUE,
		 export,
		 link);
	property BOOLEAN draw_shadow
		(nick = _("DrawShadow"),
		 blurb = _("Draw a shadow under the image"),
		 default_value = FALSE,
		export,
		link);
	property BOOLEAN squared
		(nick = "Squared",
			blurb = "Keep the widget squared",
			default_value = TRUE,
			export,
			link);

	private GtkWidget *image = { gtk_image_new()} ;
	init (self)
	{
		gtk_event_box_set_visible_window(GTK_EVENT_BOX(self), FALSE);
		gtk_container_add(GTK_CONTAINER(self), self->_priv->image);		
		gtk_container_set_resize_mode(GTK_CONTAINER(self), GTK_RESIZE_IMMEDIATE);
		gtk_widget_show_all(GTK_WIDGET(self));
		self_set_cover_na(self);
		self->_priv->status_signal = g_signal_connect_swapped(G_OBJECT(gmpcconn), "status_changed",
				G_CALLBACK(self_update_cover), G_OBJECT(self));
		self->_priv->connect_signal = g_signal_connect_swapped(G_OBJECT(gmpcconn), "connection_changed",
				G_CALLBACK(self_connection_changed), G_OBJECT(self));                            		


		self->_priv->meta_id =  0;
	}

	override (G:Object)
	void 
	finalize (self)
	{
		if(self->_priv->meta_id)
		{
			meta_data_handle_remove_request(self->_priv->meta_id);
			self->_priv->meta_id =  0;
		}




		if(self->_priv->status_signal){
			g_signal_handler_disconnect(G_OBJECT(gmpcconn), self->_priv->status_signal);
		}
		if(self->_priv->connect_signal){
			g_signal_handler_disconnect(G_OBJECT(gmpcconn), self->_priv->connect_signal);
		}
		
	}
		
	public 
	GtkWidget * new (int type)
	{
		Self *gmi =  GET_NEW;
		gmi->image_type = type;
		return (GtkWidget *)gmi;
	}
	
	public	
	void
	update_cover(self, MpdObj *mi, ChangedStatusType what, GmpcConnection *gmpcconn )
	{
		if(self->connection && what&(MPD_CST_STATE))
		{
			int state = mpd_player_get_state(mi);
			if(state == MPD_PLAYER_STOP || state == MPD_PLAYER_UNKNOWN)
			{
				self_set_cover_na(self);
			}
			else{
				mpd_Song *song = mpd_playlist_get_current_song(mi);
				if(song)
				{
					self_update_cover_from_song(self, song);
				}
				else
				{
					self_set_cover_na(self);
				}
			}
			
		}
		else if(self->connection && what&(MPD_CST_SONGID|MPD_CST_SONGPOS))
		{
			mpd_Song *song = mpd_playlist_get_current_song(mi);
			if(!song)
			{
				self_set_cover_na(self);
			}
			else
			{
				self_update_cover_from_song(self, song);
			}
		}

	}
	public 
	void
	connection_changed(self,MpdObj *mi, int connect, GmpcConnection *gmpconn)
	{
		if(!connect)
		{
			self_set_cover_na(self);
		}

	}

	public 
	void
	update_cover_from_song(self, mpd_Song *song)
	{
		self_set_cover_na(self);
		if(self->_priv->song)
			mpd_freeSong(self->_priv->song);
		if(!song)
			return;
		if(self->_priv->status_signal)
		self->_priv->song = mpd_songDup(song);

		if(self->_priv->meta_id)
		{
			meta_data_handle_remove_request(self->_priv->meta_id);
			self->_priv->meta_id =  0;
		}
		self->_priv->meta_id = meta_data_get_path_callback(song, self->image_type, self_meta_callback, self);
			
	}

	private
	void
	meta_callback(mpd_Song *song, MetaDataResult ret, char *path,gpointer data)
	{
		Self *self = data;
		if(!song || !self || !self->_priv || !self->_priv->song)
			return;
		/**
		 * Check for fields
		 */
		if(song->artist == NULL || self->_priv->song->artist == NULL)
			return;
		if(self->image_type&META_ALBUM_ART && (song->album == NULL || self->_priv->song->album == NULL))
			return;
		/**
		 * match song
		 */
		if(strcmp(song->artist, self->_priv->song->artist))
			return;
		else if(self->image_type&META_ALBUM_ART && 
				strcmp(song->album, self->_priv->song->album))
			return;
		else
		{
			if(ret == META_DATA_AVAILABLE) {
				self_set_cover_from_path(self,path); 
				self->_priv->meta_id = 0;
			} else if (ret == META_DATA_FETCHING) {
				self_set_cover_fetching(self);
			} else {
				self_set_cover_na(self);
				self->_priv->meta_id = 0;
			}
		}
	}


	public 
	void
	set_cover_na(self)
	{
		GdkPixbuf *pb,*pb2; 
		if(self->hide_on_na)
		{		
			gtk_widget_hide(GTK_WIDGET(self));
		}
		pb = gtk_widget_render_icon(GTK_WIDGET(self), self->no_cover_icon, -1, NULL);
		pb2=gdk_pixbuf_scale_simple(pb, self->size, self->size, GDK_INTERP_BILINEAR);
		gtk_image_set_from_pixbuf(GTK_IMAGE(self->_priv->image), pb2);
		if(self->squared)
			gtk_widget_set_size_request(GTK_WIDGET(self), self->size, self->size);
		g_object_unref(pb);
		g_object_unref(pb2);
	}
	public 
	void
	set_cover_fetching(self)
	{
		GdkPixbuf *pb,*pb2; 
		if(self->hide_on_na)
		{		
			gtk_widget_hide(GTK_WIDGET(self));
		}
		pb = gtk_widget_render_icon(GTK_WIDGET(self), self->loading_cover_icon, -1, NULL);
		pb2=gdk_pixbuf_scale_simple(pb, self->size, self->size, GDK_INTERP_BILINEAR);
		gtk_image_set_from_pixbuf(GTK_IMAGE(self->_priv->image), pb2);
		if(self->squared)
			gtk_widget_set_size_request(GTK_WIDGET(self), self->size, self->size);
		g_object_unref(pb);
		g_object_unref(pb2);
	}
	public 
	void
	set_cover_from_path(self, gchar *path)
	{
		GdkPixbuf *pb = NULL;
		pb = gdk_pixbuf_new_from_file_at_scale(path,self->size-self->draw_shadow*18-2,self->size-self->draw_shadow*18-2,TRUE,NULL);
		if(pb)
		{
			int width = 0; 
			int height = 0;

			if(self->draw_border)
				screenshot_add_border(&pb);	
			if(self->draw_shadow)
				screenshot_add_shadow(&pb);
			/** 
			 * Need to get pixbuf height/width before adding to image
			 * if added to image, somehow the returned values don't match anymore
			 */
			width = gdk_pixbuf_get_width(pb);			
			height = gdk_pixbuf_get_height(pb);
			gtk_image_set_from_pixbuf(GTK_IMAGE(self->_priv->image),pb);
			/**
			 * Set sizing, also set size on non-squared, so the widget resizes propperly
			 */
			if(self->squared)
			{
				gtk_widget_set_size_request(GTK_WIDGET(self), self->size, self->size);
			}
			else
			{
				gtk_widget_set_size_request(GTK_WIDGET(self), width+2, height+2);
			}
			g_object_unref(pb);
		}
		gtk_widget_show(GTK_WIDGET(self));
	}
}
