requires 2.0.0

%headertop{
#include <gtk/gtk.h>
#include <libmpd/libmpd.h>
#include "main.h"
%}


class Gmpc:MetaImage from Gtk:Event:Box{
	private gulong status_signal = {0};
	private mpd_Song *song = {NULL} destroywith mpd_freeSong;
	/** Public */

	public int size = {64};
	public int image_type = {META_ALBUM_ART};
	public MpdObj *connection= {NULL};
	public gboolean hide_on_na = {FALSE};

	property INT image_type 
		(nick = _("Image type"),
		blurb = _("Type of the image, like artist art"),
		default_value = META_ALBUM_ART,
		export,
		link);
		 
	property INT size
		(nick = _("Size"),
		blurb = _("Size of the image"),
		default_value = 64,
		export,
		link);

	property BOOLEAN hide_on_na
		(nick = _("HideOnNA"),
		blurb = _("Hide the image when not availibe"),
		default_value = FALSE,
		export,
		link);
	property POINTER connection
		(nick = _("Connection"),
		blurb = _("A mpdObj to check on"),
		default_value = NULL,
		export,
		link);

	private GtkWidget *image = { gtk_image_new()} ;
	init (self)
	{
		gtk_container_add(GTK_CONTAINER(self), self->_priv->image);		
		gtk_widget_show_all(GTK_WIDGET(self));
		self_set_cover_na(self);
		self->_priv->status_signal = g_signal_connect_swapped(G_OBJECT(gmpcconn), "status_changed",
				G_CALLBACK(self_update_cover), G_OBJECT(self));
	}

	override (G:Object)
	void 
	finalize (self)
	{
		printf("Finalizing metaimage\n");
		if(self->_priv->status_signal)
		{
			g_signal_handler_disconnect(G_OBJECT(gmpcconn), self->_priv->status_signal);
		}

	}
		
	public 
	GtkWidget * new (int type)
	{
		Self *gmi =  GET_NEW;
		gmi->image_type = type;
		return (GtkWidget *)gmi;
	}
	
	public	
	void
	update_cover(self, MpdObj *mi, ChangedStatusType what, GmpcConnection *gmpcconn )
	{
		if(self->connection && what&(MPD_CST_SONGID|MPD_CST_SONGPOS))
		{
			mpd_Song *song = mpd_playlist_get_current_song(mi);
			if(!song)
			{
				self_set_cover_na(self);
			}
			else
			{
				self_update_cover_from_song(self, song);
			}
		}

	}

	public 
	void
	update_cover_from_song(self, mpd_Song *song)
	{
		if(self->_priv->song)
			mpd_freeSong(self->_priv->song);
		self->_priv->song = mpd_songDup(song);
		meta_data_get_path_callback(song, self->image_type, self_meta_callback, self);
	}

	private
	void
	meta_callback(mpd_Song *song, MetaDataResult ret, char *path,Gmpc:MetaImage *self)
	{
		if(!strcmp(song->file, self->_priv->song->file))
		{
			if(ret == META_DATA_AVAILABLE) {
				self_set_cover_from_path(self,path); 
			} else if (ret == META_DATA_FETCHING) {
				self_set_cover_fetching(self);
			} else {
				self_set_cover_na(self);
			}
		}

	}


	public 
	void
	set_cover_na(self)
	{
		if(self->hide_on_na)
		{		
			gtk_widget_hide(GTK_WIDGET(self));
		}
		gtk_image_set_from_stock(GTK_IMAGE(self->_priv->image), "media-no-cover", -1);
	}
	public 
	void
	set_cover_fetching(self)
	{
		if(self->hide_on_na)
		{		
			gtk_widget_hide(GTK_WIDGET(self));
		}
		gtk_image_set_from_stock(GTK_IMAGE(self->_priv->image), "media-loading-cover", -1);
	}
	public 
	void
	set_cover_from_path(self, gchar *path)
	{
		GdkPixbuf *pb = NULL;
		pb = gdk_pixbuf_new_from_file_at_scale(path,self->size,self->size,TRUE,NULL);
		if(pb)
		{
			draw_pixbuf_border(pb);
			gtk_image_set_from_pixbuf(GTK_IMAGE(self->_priv->image),pb);
			g_object_unref(pb);
		}
		gtk_widget_show(GTK_WIDGET(self));
	}
}
